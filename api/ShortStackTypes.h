/*
 * Filename: ShortStackTypes.h
 *
 * Description: This file contains the definition of the enumerations
 * and data types required by the ShortStack LonTalk Compact API.
 *
 * Copyright (c) Echelon Corporation 2002-2015.  All rights reserved.
 *
 * License:
 * Use of the source code contained in this file is subject to the terms
 * of the Echelon Example Software License Agreement which is available at
 * www.echelon.com/license/examplesoftware/.
 */

#ifndef _SHORTSTACK_TYPES_H
#define _SHORTSTACK_TYPES_H

/*
 * *****************************************************************************
 * TITLE: SHORTSTACK TYPES
 * *****************************************************************************
 *
 * Definitions of the enumerations and data types required by the ShortStack
 * LonTalk Compact API.
 */

/*
 * Note this file is best included through ShortStackDev.h, which is generated by the
 * IzoT Interface Interpreter.
 */
#ifndef _LON_PLATFORM_H
#   error You must include LonPlatform.h first (prefer including ShortStackDev.h)
#endif  /* _LON_PLATFORM_H */

#ifndef DEFINED_SHORTSTACKDEV_H
#   error You must include ShortStackDev.h first
#endif  /*  DEFINED_SHORTSTACKDEV_H */

/*
 * Pull in platform specific pragmas, definitions, and so on.
 * For example, set packing directives to align objects on byte boundary.
 */
#ifdef  INCLUDE_LON_BEGIN_END
#   include "LonBegin.h"
#endif  /* INCLUDE_LON_BEGIN_END */

/*
 * *****************************************************************************
 * SECTION: ERROR CODES
 * *****************************************************************************
 *
 * This section details the error code enumerations that can be observed with
 * this API, or the ShortStack 2.1 Micro Server.
 */

/*
 * Enumeration: LonSystemError
 * System and Micro Server error codes logged in the Smart Transceiver's
 * error log.
 *
 * The codes can be accessed using the Query Status standard network management
 * command.  Starting with release 2.10, the most recent system error code is
 * also reported to the application through the <LonResetNotification> message.
 *
 * The standard system errors range above value 128. Values between 8 and 128 are
 * application-specific (but serious) errors. Values used by the ShortStack Micro
 * Server are also included in the LonSystemError enumeration. Micro Server error
 * logging is not available prior to ShortStack 2.1.
 * The standard system error codes are discussed in the Smart Transceiver
 * literature and in the CEA/EIA 709.1-B protocol specification.
 *
 * Previously named nm_error.
 */
typedef LON_ENUM_BEGIN(LonSystemError)
{
    /*   0 */    LonNoError                 = 0,

    /*
    * Micro Server-specific system error codes
    */
    /*   1 */    LonNoSmartTransceiver      = 1,   /*  1: not an EcheLon Smart Transceiver */
    /*   2 */    LonUnexpectedSiData,         /*  2: siData message is obsolete */
    /*   3 */    LonHostSelection,            /*  3: netvar_processing_off is not supported */
    /*   4 */    LonBadTransceiver,           /*  4: transceiver is not supported */
    /*   5 */    LonMessageTooBig,            /*  5: outgoing message is too big (won't fit buffer) */
    /*   6 */    LonUnknownCmd,               /*  6: unknown downlink command */
    /*   7 */    LonNvinitSizeOutOfRange,     /*  7: NVINIT payload must have 3..65 bytes payload */
    /*   8 */    LonNvinitMalformed,          /*  8: NVINIT failed plausibility check */

    /*
    * Error codes specific to remote procedure calls (RPC) used with ISI:
    */
    /*  64 */    LonRpcTimeout = 64,          /* 64: Host doesn't accept uplink RPC */
    /*  65 */    LonRpcNack,                  /* 65: RPC rejected */
    /*  66 */    LonRpcSequence,              /* 66: RPC sequence error */
    /*  67 */    LonRpcOrphanedAck,           /* 67: Received unexpected RPC ACK */
    /*  68 */    LonRpcNested,                /* 68: RPC impossible (other RPC pending) */

    /*
    * Standard system error codes
    */
    /* 129 */    LonBadEvent                = 129u,
    /* 130 */    LonNvLengthMismatch        = 130u,
    /* 131 */    LonNvMsgTooShort           = 131u,
    /* 132 */    LonEepromWriteFail         = 132u,
    /* 133 */    LonBadAddressType          = 133u,
    /* 134 */    LonPreemptionModeTimeout   = 134u,
    /* 135 */    LonAlreadyPreempted        = 135u,
    /* 136 */    LonSyncNvUpdateLost        = 136u,
    /* 137 */    LonInvalidRespAlloc        = 137u,
    /* 138 */    LonInvalidDomain           = 138u,
    /* 139 */    LonReadPastEndOfMsg        = 139u,
    /* 140 */    LonWritePastEndOfMsg       = 140u,
    /* 141 */    LonInvalidAddrTableIndex   = 141u,
    /* 142 */    LonIncompleteMsg           = 142u,
    /* 143 */    LonNvUpdateOnOutputNv      = 143u,
    /* 144 */    LonNoMsgAvail              = 144u,
    /* 145 */    LonIllegalSend             = 145u,
    /* 146 */    LonUnknownPdu              = 146u,
    /* 147 */    LonInvalidNvIndex          = 147u,
    /* 148 */    LonDivideByZero            = 148u,
    /* 149 */    LonInvalidApplError        = 149u,
    /* 150 */    LonMemoryAllocFailure      = 150u,
    /* 151 */    LonWritePastEndOfNetBuffer = 151u,
    /* 152 */    LonApplCheckSumError       = 152u,
    /* 153 */    LonCnfgCheckSumError       = 153u,
    /* 154 */    LonInvalidXcvrRegAddr      = 154u,
    /* 155 */    LonXcvrRegTimeout          = 155u,
    /* 156 */    LonWritePastEndOfApplBuffer = 156u,
    /* 157 */    LonIoReady                 = 157u,
    /* 158 */    LonSelfTestFailed          = 158u,
    /* 159 */    LonSubnetRouter            = 159u,
    /* 160 */    LonAuthenticationMismatch  = 160u,
    /* 161 */    LonSeltInstSemaphoreSet    = 161u,
    /* 162 */    LonReadWriteSemaphoreSet   = 162u,
    /* 163 */    LonApplSignatureBad        = 163u,
    /* 164 */    LonRouterFirmwareVersionMismatch = 164u
}
LON_ENUM_END(LonSystemError);

/*
 * Enumeration: LonApiError
 * ShortStack LonTalk Compact 2.1 API error codes.
 *
 * This enumeration contains all ShortStack LonTalk Compact 2.1 API error codes, including the
 * code for success _LonApiNoError_. Use the <LON_SUCCESS> macro to determine
 * successful completion of an API function.
 *
 * Note that these error codes are internal to the API.
 *
 * Previously named api_error_code.
 */
typedef LON_ENUM_BEGIN(LonApiError)
{
    /*    0    */    LonApiNoError = 0,         /* no error. Use the LON_SUCCESS macro to test for this condition */
    /*
    * API errors related to network variables
    */
    /*    1    */    LonApiNvIndexInvalid = 1,  /* invalid NV index */
    /*    2    */    LonApiNvLengthMismatch,    /* assumed length is not equal to actual length */
    /*    3    */    LonApiNvLengthTooLong,     /* NV data is too long */
    /*    4    */    LonApiNvPollNotPolledNv,   /* polling input NV requires declaration of polled attribute in the model file */
    /*    5    */    LonApiNvPollOutputNv,      /* cannot poll output network variables */
    /*    6    */    LonApiNvPropagateInputNv,  /* cannot propagate input network variable */
    /*    7    */    LonApiNvPropagatePolledNv, /* cannot propagate a polled network variable */
    /*    8    */    LonApiNvUnsupported,       /* cannot support feature (e.g. truncation, encryption) */
    /*    9    */    LonApiNvBadCypher,         /* processing error when encrypting or decrypting */

    /*
    * API errors related to application messages
    */
    /*    11   */    LonApiMsgExplicitAddrMissing = 11, /* explicit destination required but missing */
    /*    12   */    LonApiMsgInvalidMsgTag,    /* invalid message tag provided */
    /*    13   */    LonApiMsgLengthTooLong,    /* message data exceeds limits */
    /*    14   */    LonApiMsgNotRequest,       /* message should be sent as a request */
    /*    15   */    LonApiMsgInvalidCode,      /* invalid message code */
    /*    16   */    LonApiMsgInvalidCorrelator, /* Invalid <LonCorrelator> */
    /*    17   */    LonApiMsgInvalidAddress,   /* Invalid address */
    /*    21   */    LonApiNmNdAlreadyPending     = 21,   /* NM/ND message already pending */
    /*
    * API errors related to the link layer driver
    */
    /*    31   */    LonApiTxBufIsFull              = 31,   /* no transmit (downlink) buffer available */
    /*    32   */    LonApiRxMsgNotAvailable,               /* no message has been received from the Micro Server */
    /*    33   */    LonApiMicroServerUnresponsive,         /* the Micro Server is not responding to RTS */
    /*    34   */    LonApiQueueNotOpen,                   /* an input or output queue has not been created correctly */
    /*    35   */    LonApiDriverCtrl,             /* error controlling an asynchronous driver */
    /*    36   */    LonApiTimeout,                    /* a timeout occurred */
    /*
    * General API errors
    */
    /*    41   */    LonApiVersionNotAvailable    = 41, /* Link Layer protocol version information unavailable */
    /*    42   */    LonApiNeuronIdNotAvailable,    /* Unique ID (Neuron ID) unavailable */
    /*    43   */    LonApiInitializationFailure,   /* Initialization failed */
    /*    44   */    LonApiIndexInvalid,            /* invalid index (for NV indices, see LonApiNvIndexInvalid) */
    /*    45   */    LonApiMessageNotAvailable,     /* message not available */
    /*    46   */    LonApiNotInitialized,          /* API is not currently initialized.  Call <LonInit>. */
    /*    47   */    LonApiVersionNotSupported,     /* Structure version not supported. */
    /*    48   */    LonApiNotAllowed,              /* Operation not allowed */
    /*    49   */    LonApiInvalidParameter,        /* Invalid parameter specified */
    /*    50   */    LonApiOffline,                 /* Operation not allowed while device is offline. */
    /*    51   */    LonApiNotSupported,          /* a specific API or subset thereof is not supported */
    /*
    * Non-Volatile Data errors (FTXL only).  Returned by NVD callback functions.
    */
    /*    71   */   LonApiInvalidSegmentType   = 71, /* Not a supported NVD segment type. */
    /*    72   */   LonApiNvdFailure,                /* Generic non-volatile data failure. */
    /*    73   */   LonApiNvdSizeNotSupported,       /* Non-volatile data size is not supported. */
    /*    74   */   LonApiNvdFileError,              /* Non-volatile data access error. */
    /*
    * Direct Memory File (DMF) access errors.
    */
    /*    78   */   LonApiDmfOutOfRange         = 81, /* DMF address + count is out of range for operation. */
    /*    79   */   LonApiDmfReadOnly           = 82, /* Write to read-only DMF area. */
    /*    80   */   LonApiDmfNoDriver           = 83  /* No DMF driver defined. */
}
LON_ENUM_END(LonApiError);

/*
 * Macro: LON_SUCCESS
 * Use the LON_SUCCESS macro to convert a <LonApiError> code into a boolean
 * success or failure indicator
 */
#define LON_SUCCESS(n)   ((n) == LonApiNoError)

/*
 * ******************************************************************************
 * SECTION: GENERAL ENUMERATIONS AND TYPES
 * ******************************************************************************
 *
 * This section contains the enumerations and data types used with the ShortStack LonTalk Compact 2.1 API
 */

/*
 *  Macros: LON_GET_UNSIGNED_WORD, LON_SET_UNSIGNED_WORD
 *  Converts LonWord into a LonUbits16
 *  and converts a LonUbits16 into a LonWord.
 */
#define LON_GET_UNSIGNED_WORD(n)          (((LonUbits16)((n).msb) << 8)+(LonUbits16)((n).lsb))
#define LON_SET_UNSIGNED_WORD(n, v)       (n).msb = (LonByte)((v)>>8); (n).lsb = (LonByte)(v)

/*
 *  Macros: LON_GET_SIGNED_WORD, LON_SET_SIGNED_WORD
 *  Converts LonWord into a LonBits16
 *  and converts a LonBits16 into a LonWord.
 */
#define LON_GET_SIGNED_WORD(n)            ((LonBits16)LON_GET_UNSIGNED_WORD(n))
#define LON_SET_SIGNED_WORD(n, v)         LON_SET_UNSIGNED_WORD(n, v)

/*
 *  Macros: LON_GET_UNSIGNED_DOUBLEWORD, LON_SET_UNSIGNED_DOUBLEWORD
 *  Converts LonDoubleWord into a LonUbits32
 *  and converts a LonUbits32 into a LonDoubleWord.
 */
#define LON_GET_UNSIGNED_DOUBLEWORD(n)    ((((LonUbits32)LON_GET_UNSIGNED_WORD((n).msw)) << 16) \
                                          +(LonUbits32)LON_GET_UNSIGNED_WORD((n).lsw))
#define LON_SET_UNSIGNED_DOUBLEWORD(n, v) LON_SET_UNSIGNED_WORD((n).msw, (LonBits16) ((v) >> 16)); \
                                          LON_SET_UNSIGNED_WORD((n).lsw, (LonBits16) (v))

/*
 *  Macros: LON_GET_SIGNED_DOUBLEWORD, LON_SET_SIGNED_DOUBLEWORD
 *  Converts LonDoubleWord into a LonBits32
 *  and converts a LonBits32 into a LonDoubleWord.
 */
#define LON_GET_SIGNED_DOUBLEWORD(n)    ((LonBits32)LON_GET_UNSIGNED_DOUBLEWORD(n))
#define LON_SET_SIGNED_DOUBLEWORD(n, v) LON_SET_UNSIGNED_DOUBLEWORD(n, v)

/*
 *  Macros: LON_GET_ATTRIBUTE, LON_SET_ATTRIBUTE
 *  Gets(sets) attributes from(to) a field by appropriately masking and shifting.
 */
#define LON_GET_ATTRIBUTE(var, n)           ((((var).n##_FIELD) & n##_MASK) >> n##_SHIFT)
#define LON_SET_ATTRIBUTE(var, n, value)    ((var).n##_FIELD = (((var).n##_FIELD) & ~n##_MASK) | ((value) << n##_SHIFT))

/*
 *  Macro: LON_LINK_LAYER_PROTOCOL_VERSION
 *  The current link layer protocol version as implemented by the API.
 */
#define LON_LINK_LAYER_PROTOCOL_VERSION     3

/*
 *  Macro: LON_DOMAIN_ID_MAX_LENGTH
 *  Maximum length of the domain identifier, in bytes.
 *
 *  The domain identifier can be zero, one, three, or LON_DOMAIN_ID_MAX_LENGTH (6) bytes long.
 *  Space for the largest possible identifier is allocated in various structures and message
 *  types. See <LonDomain> for the domain table structure.
 */
#define LON_DOMAIN_ID_MAX_LENGTH    6

/*
 *  Macro: LON_AUTHENTICATION_KEY_LENGTH
 *  Length of the authentication key, stored in the domain table (<LonDomain>).
 *
 *  Previously named AUTH_KEY_LEN.
 */
#define LON_AUTHENTICATION_KEY_LENGTH   6

/*
 *  Macro: LON_PROGRAM_ID_LENGTH
 *  Length of the application's program identifier, in bytes.
 *
 *  Previously named ID_STR_LEN.
 */
#define LON_PROGRAM_ID_LENGTH   8

/*
 *  Macro: LON_LOCATION_LENGTH
 *  Length of the location identifier, in bytes.
 */
#define LON_LOCATION_LENGTH     6

/*
 *  Macro: LON_UNIQUE_ID_LENGTH
 *  Length of the node's unique identifier, in bytes.
 *
 *  The Unique ID is typically known as the Neuron ID, referring to the
 *  Neuron Chip's or Smart Transceiver's unique ID.
 *  Previously named NEURON_ID_LEN.
 */
#define LON_UNIQUE_ID_LENGTH    6

/*
 *  Macro: LON_COMMUNICATIONS_PARAMETER_LENGTH
 *  Number of communication control bytes.
 *
 *  Previously named NUM_COMM_PARAMS.
 */
#define LON_COMMUNICATIONS_PARAMETER_LENGTH     7

/*
 *  Typedef: LonTransceiverParameters
 *  Parameters for single-ended and special-purpose mode transceivers.
 *
 *  See <LonDirectModeTransceiver> for direct-mode transceiver parameters.
 *  Previously named xcvr_status_struct.
 */
typedef LonByte  LonTransceiverParameters[LON_COMMUNICATIONS_PARAMETER_LENGTH];

/*
 *  Typedef: LonUniqueId
 *  Holds the unique ID.
 */
typedef LonByte  LonUniqueId[LON_UNIQUE_ID_LENGTH];

/*
 *  Typedef: LonProgramId
 *  Holds the program ID.
 */
typedef LonByte  LonProgramId[LON_PROGRAM_ID_LENGTH];

/*
 *  Typedef: LonDomainId
 *  Holds a single domain identifier.
 */
typedef LonByte  LonDomainId[LON_DOMAIN_ID_MAX_LENGTH];

/*
 *  Typedef: LonAuthenticationKey
 *  Holds a single authentication key.
 */
typedef LonByte  LonAuthenticationKey[LON_AUTHENTICATION_KEY_LENGTH];

/*
 *  Typedef: LonLocationId
 *  Holds a single location identifier.
 *
 *  The location identifier is often referred to as the "location string".
 *  Note that this is misleading, because this data is not limited to ASCII characters
 *  or other similar requirements that could be inferred from the word "string".
 */
typedef LonByte  LonLocationId[LON_LOCATION_LENGTH];

/*
 *  Typedef: LonSubnetId
 *  Holds a subnet identifier.
 */
typedef LonByte  LonSubnetId;

/*
 *  Typedef: LonGroupId
 *  Holds a group identifier.
 */
typedef LonByte  LonGroupId;

/*
 *  Typedef: LonNodeId
 *  Holds a node identifier.
 */
typedef LonByte  LonNodeId;

/*
 *  Enumeration: LonNeuronModel
 *  Neuron Chip and Smart Transceiver model codes.
 *
 *  This enumeration lists all model codes for Neuron Chips or Smart Transceivers.
 *  An FTXL Transceiver has modal code LonNeuron3120E4Code (14).
 *  Previously named nm_model_code.
 */
typedef LON_ENUM_BEGIN(LonNeuronModel)
{
    /*   0 */    LonNeuron3150Code    =  0,  /* 3150, FT 3150, CY7C53150 */
    /*   1 */    LonNeuronPl3150Code  =  1,  /* PL 3150 */
    /*   2 */    LonNeuron3150LCode   =  2,  /* CY7C53150L */
    /*   8 */    LonNeuron3120Code    =  8,  /* Legacy 3120, TMPN3120AM, TMPN3120B1M, TMPN3120B1AM, MC143120B1 */
    /*   9 */    LonNeuron3120E1Code  =  9,  /* 3120E1, TMPN3120E1M, TMPN3120FE1M */
    /*  10 */    LonNeuron3120E2Code  = 10,  /* 3120E2, CY7C53120E2, MC143120E2 */
    /*  11 */    LonNeuron3120E3Code  = 11,  /* 3120E3, TMPN3120FE3M */
    /*  12 */    LonNeuron3120A20Code = 12,  /* 3120A20, TMPN3120A20M/U */
    /*  13 */    LonNeuron3120E5Code  = 13,  /* 3120E5, TMPN3120FE5M */
    /*  14 */    LonNeuron3120E4Code  = 14,  /* CY7C53120E4, FT 3120-E4 */
    /*  15 */    LonNeuronPl3120E4Code = 15, /* PL 3120-E4 */
    /*  16 */    LonNeuron3120L8Code  = 16,  /* CY7C53120L8 */
    /*  17 */    LonNeuronPl3170Code  = 17,  /* PL 3170 */
    /*  32 */    LonNeuronFt5000Code  = 32,  /* FT 5000 */
    /*  33 */    LonNeuron5000Code    = 33   /* Neuron 5000 */
}
LON_ENUM_END(LonNeuronModel);

/*
 *  Enumeration: LonNeuronState
 *  Neuron Chip and Smart Transceiver state values.
 *
 *  This enumeration contains the values of the Neuron Chip's and Smart Transceiver's state information.
 *  To convert the state value returned by the Query Status command to one of these values, use the
 *  <LON_NODE_STATE> macro. To test for the offline flag, use the <LON_NODE_STATE_OFFLINE> macro.
 *  Previously named nm_node_state.
 */

#define LON_OFFLINE_BIT     0x08
#define LON_NODE_STATE_MASK 0x07

/*
 *  Macro: LON_NEURON_STATE
 *  Obtain persistent Neuron state information.
 *
 *  Use this macro to obtain the 3-bit Neuron state that is stored in EEPROM.
 *  Previously named NEURON_STATE.
 */
#define LON_NEURON_STATE(state) ((state) & LON_NODE_STATE_MASK)

/*
 *  Macro: LON_NODE_STATE
 *  Extracts state information from <LonNeuronState>.
 *
 *  Use this macro to decipher the status information encoded within the <LonNeuronState> enumeration.
 *  Previously named NODE_STATE.
 */
#define LON_NODE_STATE(state)   ((LON_NEURON_STATE(state) == LonConfigOnLine) ? (state) : LON_NEURON_STATE(state))

/*
 *  Macro: LON_NODE_STATE_OFFLINE
 *  Extracts offline details from <LonNeuronState>.
 *
 *  Use this macro to query the node's offline modes.
 *  Previously named NODE_STATE_OFFLINE.
 */
#define LON_NODE_STATE_OFFLINE(state)   (LON_NEURON_STATE(state) == LonConfigOffLine || ((state) & LON_OFFLINE_BIT))

/*
 *  Typedef: LonNodeState
 *  Decodes the node's state.
 *
 *  Previously named nm_node_state.
 */
typedef LON_ENUM_BEGIN(LonNodeState)
{
    /*  0 */    LonStateInvalid          = 0,    /* invalid or Echelon use only          */
    /*  1 */    LonStateInvalid_1        = 1,    /* equivalent to StateInvalid          */
    /*  2 */    LonApplicationUnconfig   = 2,    /* has application, unconfigured        */
    /*  3 */    LonNoApplicationUnconfig = 3,    /* applicationless, unconfigured        */
    /*  4 */    LonConfigOnLine          = 4,    /* configured, online                   */
    /*  5 */    LonStateInvalid_5        = 5,    /* equivalent to StateInvalid          */
    /*  6 */    LonConfigOffLine         = 6,    /* hard offline                         */
    /*  7 */    LonStateInvalid_7        = 7,    /* equivalent to StateInvalid          */
    /* 12 */    LonSoftOffLine           = (LonConfigOnLine | LON_OFFLINE_BIT), /* (12) configured, soft-offline        */
    /*0x8C*/    LonConfigByPass          = 0x8C  /* configured, in bypass mode          */
}
LON_ENUM_END(LonNodeState);

/*
 * Enumeration: LonNodeMode
 * Control node mode with <LonNmSetNodeModeRequest>.
 *
 * Previously named nm_node_mode.
 */
typedef LON_ENUM_BEGIN(LonNodeMode)
{
    LonApplicationOffLine  = 0,
    LonApplicationOnLine   = 1,
    LonApplicationReset    = 2,
    LonChangeState         = 3
}
LON_ENUM_END(LonNodeMode);

/*
 *  Enumeration: LonResetCause
 *  Decodes the last reset cause.
 *
 *  The reset cause can be accessed through the <LonStatus> structure.
 */
typedef LON_ENUM_BEGIN(LonResetCause)
{
    /* 0x00 */  LonResetCleared     = 0x00,
    /* 0x01 */  LonPowerUpReset     = 0x01,
    /* 0x02 */  LonExternalReset    = 0x02,
    /* 0x0C */  LonWatchdogReset    = 0x0C,
    /* 0x14 */  LonSoftwareReset    = 0x14
}
LON_ENUM_END(LonResetCause);

/*
 *  Enumeration: LonAddressType
 *  Denotes destination address type.
 *
 *  This enumeration holds the literals for the 'type' field of destination addresses for outgoing messages.
 *  Previously named AddrType.
 */
typedef LON_ENUM_BEGIN(LonAddressType)
{
    /*  0 */    LonAddressUnassigned    = 0,
    /*  1 */    LonAddressSubnetNode,
    /*  2 */    LonAddressUniqueId,         /* Previously named LonAddressNeuronId */
    /*  3 */    LonAddressBroadcast,
    /*127 */    LonAddressLocal         = 127
}
LON_ENUM_END(LonAddressType);

/*
 *  Enumeration: LonRepeatTimer
 *  Encoded repeat timer values.
 *
 *  This enumeration defines the encoded repeat timer values.
 */
typedef LON_ENUM_BEGIN(LonRepeatTimer)
{
    /*  0 */ LonRpt16,      /* 16 ms */
    /*  1 */ LonRpt24,      /* 24 ms */
    /*  2 */ LonRpt32,      /* 32 ms */
    /*  3 */ LonRpt48,      /* 48 ms */
    /*  4 */ LonRpt64,      /* 64 ms */
    /*  5 */ LonRpt96,      /* 96 ms */
    /*  6 */ LonRpt128,     /* 128 ms */
    /*  7 */ LonRpt192,     /* 192 ms */
    /*  8 */ LonRpt256,     /* 256 ms */
    /*  9 */ LonRpt384,     /* 384 ms */
    /* 10 */ LonRpt512,     /* 512 ms */
    /* 11 */ LonRpt768,     /* 768 ms */
    /* 12 */ LonRpt1024,    /* 1024 ms */
    /* 13 */ LonRpt1536,    /* 1536 ms */
    /* 14 */ LonRpt2048,    /* 2048 ms */
    /* 15 */ LonRpt3072     /* 3072 ms */
}
LON_ENUM_END(LonRepeatTimer);

/*
 *  Enumeration: LonReceiveTimer
 *  Encoded receive timer values.
 *
 *  This enumeration defines the encoded receive timer values used with groups.
 *  For the non-group receive timer, see <LonNonGroupReceiveTimer>.
 */
typedef LON_ENUM_BEGIN(LonReceiveTimer)
{
    /*  0 */ LonRcv128,     /* 128 ms */
    /*  1 */ LonRcv192,     /* 192 ms */
    /*  2 */ LonRcv256,     /* 256 ms */
    /*  3 */ LonRcv384,     /* 384 ms */
    /*  4 */ LonRcv512,     /* 512 ms */
    /*  5 */ LonRcv768,     /* 768 ms */
    /*  6 */ LonRcv1024,    /* 1024 ms */
    /*  7 */ LonRcv1536,    /* 1536 ms */
    /*  8 */ LonRcv2048,    /* 2048 ms */
    /*  9 */ LonRcv3072,    /* 3072 ms */
    /* 10 */ LonRcv4096,    /* 4096 ms */
    /* 11 */ LonRcv6144,    /* 6144 ms */
    /* 12 */ LonRcv8192,    /* 8192 ms */
    /* 13 */ LonRcv12288,   /* 12288 ms */
    /* 14 */ LonRcv16384,   /* 16384 ms */
    /* 15 */ LonRcv24576    /* 24576 ms */
}
LON_ENUM_END(LonReceiveTimer);

/*
 *  Enumeration: LonNonGroupReceiveTimer
 *  Encoded non-group receive timer values.
 *
 *  This enumeration defines the encoded values for the receive timer used with any
 *  addressing modes other than groups. For the receive timer used with groups, use
 *  <LonReceiveTimer>.
 */
typedef LonReceiveTimer LonNonGroupReceiveTimer;

/*
 *  Enumeration: LonTransmitTimer
 *  Encoded transmit timer values.
 *
 *  This enumeration defines the encoded transmit timer values.
 */
typedef LON_ENUM_BEGIN(LonTransmitTimer)
{
    /*  0 */ LonTx16,      /* 16 ms */
    /*  1 */ LonTx24,      /* 24 ms */
    /*  2 */ LonTx32,      /* 32 ms */
    /*  3 */ LonTx48,      /* 48 ms */
    /*  4 */ LonTx64,      /* 64 ms */
    /*  5 */ LonTx96,      /* 96 ms */
    /*  6 */ LonTx128,     /* 128 ms */
    /*  7 */ LonTx192,     /* 192 ms */
    /*  8 */ LonTx256,     /* 256 ms */
    /*  9 */ LonTx384,     /* 384 ms */
    /* 10 */ LonTx512,     /* 512 ms */
    /* 11 */ LonTx768,     /* 768 ms */
    /* 12 */ LonTx1024,    /* 1024 ms */
    /* 13 */ LonTx1536,    /* 1536 ms */
    /* 14 */ LonTx2048,    /* 2048 ms */
    /* 15 */ LonTx3072     /* 3072 ms */
}
LON_ENUM_END(LonTransmitTimer);

/*
 * ******************************************************************************
 * SECTION: ADDRESSING TYPES
 * ******************************************************************************
 *
 *  This section contains definitions used with source addresses, destination addresses,
 *  and the address table.
 */

/*
 *  Typedef: LonSendGroup
 *  Destination address type for group addressing.
 *
 *  Group address structure, used for multicast destination addresses with <LonSendAddress>.
 *  Previously named SendGroup.
 */

/*
 * Use the LON_SENDGROUP_TYPE_* macros to access the Type field in LonSendGroup.TypeSize
 */
#define LON_SENDGROUP_TYPE_MASK     0x80    /* One for group, zero for all other address types */
#define LON_SENDGROUP_TYPE_SHIFT    7
#define LON_SENDGROUP_TYPE_FIELD    TypeSize

/*
 * Use the LON_SENDGROUP_SIZE_* macros to access the Size field in LonSendGroup.TypeSize
 */
#define LON_SENDGROUP_SIZE_MASK     0x7F    /* group size, or zero for unlimited group size */
#define LON_SENDGROUP_SIZE_SHIFT    0
#define LON_SENDGROUP_SIZE_FIELD    TypeSize

/*
 * Use the LON_SENDGROUP_DOMAIN_* macros to access the Domain field in LonSendGroup.DomainMember
 */
#define LON_SENDGROUP_DOMAIN_MASK   0x80    /* domain index for this group, zero or one */
#define LON_SENDGROUP_DOMAIN_SHIFT  7
#define LON_SENDGROUP_DOMAIN_FIELD  DomainMember

/*
 * Use the LON_SENDGROUP_MEMBER_* macros to access the Member field in LonSendGroup.DomainMember
 */
#define LON_SENDGROUP_MEMBER_MASK   0x7F    /* member ID within the group (0-63). Use zero for unlimited groups */
#define LON_SENDGROUP_MEMBER_SHIFT  0
#define LON_SENDGROUP_MEMBER_FIELD  DomainMember

/*
 * Use the LON_SENDGROUP_REPEAT_TIMER_* macros to access the RepeatTimer field in LonSendGroup.RepeatRetry
 */
#define LON_SENDGROUP_REPEAT_TIMER_MASK     0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration */
#define LON_SENDGROUP_REPEAT_TIMER_SHIFT    4
#define LON_SENDGROUP_REPEAT_TIMER_FIELD    RepeatRetry

/*
 * Use the LON_SENDGROUP_RETRY_* macros to access the Retry field in LonSendGroup.RepeatRetry
 */
#define LON_SENDGROUP_RETRY_MASK    0x0F    /* number of retries, or number of transmissions minus one for unacknowledged service */
#define LON_SENDGROUP_RETRY_SHIFT   0
#define LON_SENDGROUP_RETRY_FIELD   RepeatRetry

/*
 * Use the LON_SENDGROUP_RECEIVE_TIMER_* macros to access the ReceiveTimer field in LonSendGroup.ReceiveTransmit
 */
#define LON_SENDGROUP_RECEIVE_TIMER_MASK    0xF0   /* receive timer. Use values from the <LonReceiveTimer> enumeration */
#define LON_SENDGROUP_RECEIVE_TIMER_SHIFT   4
#define LON_SENDGROUP_RECEIVE_TIMER_FIELD   ReceiveTransmit

/*
 * Use the LON_SENDGROUP_TRANSMIT_TIMER_* macros to access the TransmitTimer field in LonSendGroup.ReceiveTransmit
 */
#define LON_SENDGROUP_TRANSMIT_TIMER_MASK   0x0F   /* transmit timer. Use values from the <LonTransmitTimer> enumeration */
#define LON_SENDGROUP_TRANSMIT_TIMER_SHIFT  0
#define LON_SENDGROUP_TRANSMIT_TIMER_FIELD  ReceiveTransmit

typedef LON_STRUCT_BEGIN(LonSendGroup)
{
    LonByte     TypeSize;       /* contains type, size. See LON_SENDGROUP_TYPE_* and _SIZE_* macros */
    LonByte     DomainMember;   /* contains domain, member. See LON_SENDGROUP_DOMAIN_* and _MEMBER_* macros */
    LonByte     RepeatRetry;    /* contains repeat, retry. See LON_SENDGROUP_REPEAT_* and _RETRY_* macros */
    LonByte     ReceiveTransmit;/* contains receive and transmit timers. See LON_SENDGROUP_RECEIVE_* and _TRANSMIT_* macros */
    LonGroupId  GroupId;     /* the group ID, 0..255 */
}
LON_STRUCT_END(LonSendGroup);

/*
 *  Typedef: LonSendSubnetNode
 *  Destination address type for subnet/node addressing.
 *
 *  Subnet/Node address structure, used for unicast destination addresses with <LonSendAddress>.
 *  Previously named SendSnode.
 */

/*
 * Use the LON_SENDSN_DOMAIN_* macros to access the Domain field in LonSendSubnetNode.DomainNode
 */
#define LON_SENDSN_DOMAIN_MASK  0x80    /* domain index, zero or one */
#define LON_SENDSN_DOMAIN_SHIFT 7
#define LON_SENDSN_DOMAIN_FIELD DomainNode

/*
 * Use the LON_SENDSN_NODE_* and LON_NODEID_* macros to access the Node field in LonSendSubnetNode.DomainNode
 */
#define LON_SENDSN_NODE_MASK    0x7F    /* node ID 0-127 in this subnet, this domain */
#define LON_SENDSN_NODE_SHIFT   0
#define LON_SENDSN_NODE_FIELD   DomainNode

/*
 * Use the LON_SENDSN_REPEAT_* macros to access the Repeat field in LonSendSubnetNode.RepeatRetry
 */
#define LON_SENDSN_REPEAT_TIMER_MASK    0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration */
#define LON_SENDSN_REPEAT_TIMER_SHIFT   4
#define LON_SENDSN_REPEAT_TIMER_FIELD   RepeatRetry

/*
 * Use the LON_SENDSN_RETRY_* macros to access the Retry field in LonSendSubnetNode.RepeatRetry
 */
#define LON_SENDSN_RETRY_MASK   0x0F    /* number of retries, or number of transmissions minus one for unacknowledged service */
#define LON_SENDSN_RETRY_SHIFT  0
#define LON_SENDSN_RETRY_FIELD  RepeatRetry

/*
 * Use the LON_SENDSN_TRANSMIT_TIMER_* macros to access the tx_timer field in LonSendSubnetNode.RsvdTransmit
 */
#define LON_SENDSN_TRANSMIT_TIMER_MASK  0x0F    /* transmit timer. Use values from the <LonTransmitTimer> enumeration */
#define LON_SENDSN_TRANSMIT_TIMER_SHIFT  0
#define LON_SENDSN_TRANSMIT_TIMER_FIELD  RsvdTransmit

typedef LON_STRUCT_BEGIN(LonSendSubnetNode)
{
    LON_ENUM(LonAddressType)    Type;           /* should be LonAddressSubnetNode for subnet/node addressing */
    LonByte                     DomainNode;     /* contains domain, node. See LON_SENDSN_DOMAIN_* and _NODE_* macros */
    LonByte                     RepeatRetry;    /* contains repeat, retry. See LON_SENDSN_REPEAT_* and _RETRY_* macros */
    LonByte                     RsvdTransmit;   /* contains transmit (top 4 bits are unused). See LON_SENDSN_TRANSMIT_TIMER_* macros */
    LonSubnetId                 Subnet;         /* destination subnet number, 1..255    */
}
LON_STRUCT_END(LonSendSubnetNode);

/*
 *  Typedef: LonSendUniqueId
 *  Destination address type for Unique ID (Neuron ID) addressing.
 *
 *  Unique ID (Neuron ID) address structure, used for unicast destination addresses with <LonSendAddress>.
 *  Previously named SendNrnid.
 */

/*
 * Use the LON_SENDNID_DOMAIN_* macros to access the Domain field in LonSendUniqueId.DomainNode
 */
#define LON_SENDNID_DOMAIN_MASK     0x80    /* domain index, zero or one */
#define LON_SENDNID_DOMAIN_SHIFT    7
#define LON_SENDNID_DOMAIN_FIELD    Domain

/*
 * Use the LON_SENDNID_REPEAT_* macros to access the Repeat field in LonSendUniqueId.RepeatRetry
 */
#define LON_SENDNID_REPEAT_TIMER_MASK   0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration */
#define LON_SENDNID_REPEAT_TIMER_SHIFT  4
#define LON_SENDNID_REPEAT_TIMER_FIELD  RepeatRetry

/*
 * Use the LON_SENDNID_RETRY_* macros to access the Retry field in LonSendUniqueId.RepeatRetry
 */
#define LON_SENDNID_RETRY_MASK      0x0F    /* number of retries, or number of transmissions minus one for unacknowledged service */
#define LON_SENDNID_RETRY_SHIFT     0
#define LON_SENDNID_RETRY_FIELD     RepeatRetry

/*
 * Use the LON_SENDNID_TRANSMIT_TIMER_* macros to access the tx_timer field in LonSendUniqueId.RsvdTransmit
 */
#define LON_SENDNID_TRANSMIT_TIMER_MASK     0x0F    /* transmit timer. Use values from the <LonTransmitTimer> enumeration */
#define LON_SENDNID_TRANSMIT_TIMER_SHIFT    0
#define LON_SENDNID_TRANSMIT_TIMER_FIELD    RsvdTransmit

typedef LON_STRUCT_BEGIN(LonSendUniqueId)
{
    LON_ENUM(LonAddressType)    Type;           /* should be LonAddressNeuronId */
    LonByte                     Domain;         /* contains the domain index. See LON_SENDNID_DOMAIN_*  macro. The remaining 7 bits must be zero */
    LonByte                     RepeatRetry;    /* contains repeat, retry. See LON_SENDNID_REPEAT_* and _RETRY_* macros */
    LonByte                     RsvdTransmit;   /* contains transmit (top 4 bits are unused). See LON_SENDNID_TRANSMIT_TIMER_* macros */
    LonSubnetId                 Subnet;         /* destination subnet number, 1..255, or zero to pass all routers    */
    LonUniqueId                 NeuronId;       /* 48-bit unique ID of Neuron Chip or Smart Transceiver */
}
LON_STRUCT_END(LonSendUniqueId);

/*
 *  Typedef: LonSendBroadcast
 *  Destination address type for broadcast addressing.
 *
 *  Broadcst address structure, used for multicast destination addresses with <LonSendAddress>.
 *  Previously named SendBcast.
 */

/*
 * Use the LON_SENDBCAST_DOMAIN_* macros to access the Domain field in LonSendBroadcast.DomainRsvdBacklog
 */
#define LON_SENDBCAST_DOMAIN_MASK   0x80    /* domain index, zero or one */
#define LON_SENDBCAST_DOMAIN_SHIFT  7
#define LON_SENDBCAST_DOMAIN_FIELD  DomainRsvdBacklog

/*
 * Use the LON_SENDBCAST_BACKLOG_* macros to access the Backlog field in LonSendBroadcast.DomainRsvdBacklog
 */
#define LON_SENDBCAST_BACKLOG_MASK  0x3F   /* backlog (set to zero if unknown) */
#define LON_SENDBCAST_BACKLOG_SHIFT 0
#define LON_SENDBCAST_BACKLOG_FIELD DomainRsvdBacklog

/*
 * Use the LON_SENDBCAST_REPEAT_* macros to access the Repeat field in LonSendBroadcast.RepeatRetry
 */
#define LON_SENDBCAST_REPEAT_TIMER_MASK     0xF0    /* repeat timer. Use values from the <LonRepeatTimer> enumeration */
#define LON_SENDBCAST_REPEAT_TIMER_SHIFT    4
#define LON_SENDBCAST_REPEAT_TIMER_FIELD    RepeatRetry

/*
 * Use the LON_SENDBCAST_RETRY_* macros to access the Retry field in LonSendBroadcast.RepeatRetry
 */
#define LON_SENDBCAST_RETRY_MASK    0x0F    /* number of retries, or number of transmissions minus one for unacknowledged service */
#define LON_SENDBCAST_RETRY_SHIFT   0
#define LON_SENDBCAST_RETRY_FIELD   RepeatRetry

/*
 * Use the LON_SENDBCAST_TRANSMIT_TIMER_* macros to access the tx_timer field in LonSendBroadcast.RsvdTransmit
 */
#define LON_SENDBCAST_TRANSMIT_TIMER_MASK   0x0F    /* transmit timer. Use values from the <LonTransmitTimer> enumeration */
#define LON_SENDBCAST_TRANSMIT_TIMER_SHIFT  0
#define LON_SENDBCAST_TRANSMIT_TIMER_FIELD  RsvdTransmit

typedef LON_STRUCT_BEGIN(LonSendBroadcast)
{
    LON_ENUM(LonAddressType)    Type;               /* should be LonAddressBroadcast */
    LonByte                     DomainRsvdBacklog;  /* contains domain, backlog (6th bit is unused). See LON_SENDBCAST_DOMAIN_* and _BACKLOG_* macros */
    LonByte                     RepeatRetry;        /* contains repeat, retry. See LON_SENDBCAST_REPEAT_* and _RETRY_* macros */
    LonByte                     RsvdTransmit;       /* contains transmit (top 4 bits are unused). See LON_SENDBCAST_TRANSMIT_TIMER_* macros */
    LonSubnetId                 Subnet;             /* destination subnet number, 1..255 for subnet broadcast, zero for domain broadcast */
}
LON_STRUCT_END(LonSendBroadcast);

/*
 *  Typedef: LonSendUnassigned
 *  Address format to clear an address table entry.
 *
 *  Sets the first 2 bytes of the address table entry to 0.
 *  Previously named SendUnassigned.
 */
typedef LON_STRUCT_BEGIN(LonSendUnassigned)
{
    LON_ENUM(LonAddressType)    Type;   /* should be LonAddressUnassigned */
}
LON_STRUCT_END(LonSendUnassigned);

/*
 *  Typedef: LonSendLocal
 *  Destination address type to address the own node locally with <LonSendAddress>.
 *
 *  Previously named SendLocal.
 */
typedef LON_STRUCT_BEGIN(LonSendLocal)
{
    LON_ENUM(LonAddressType)    Type;   /* should be LonAddressLocal */
}
LON_STRUCT_END(LonSendLocal);

/*
 * Typedef: LonSendAddress
 * Union of all possible destination address formats.
 *
 * Previously named SendAddrDtl.
 */
typedef LON_UNION_BEGIN(LonSendAddress)
{
    LonSendUnassigned   Unassigned;
    LonSendGroup        Group;
    LonSendSubnetNode   SubnetNode;
    LonSendBroadcast    Broadcast;
    LonSendUniqueId     UniqueId;
    LonSendLocal        Local;
}
LON_UNION_END(LonSendAddress);

/*
 *  Typedef: LonReceiveSubnetNode
 *  Received subnet/node ID destination addresses, used with unicast messages.
 *
 *  Used with <LonReceiveDestination> and <LonReceiveAddress>.
 *  Previously named RcvSnode and RcvSrcAddr.
 */

/*
 * Use the LON_RECEIVESN_NODE_* macros to access the LonReceiveSubnetNode.Node field
 */
#define LON_RECEIVESN_NODE_MASK     0x7F    /* node Id 0..127, MSB is reserved */
#define LON_RECEIVESN_NODE_SHIFT    0
#define LON_RECEIVESN_NODE_FIELD    Node

typedef LON_STRUCT_BEGIN(LonReceiveSubnetNode)
{
    LonByte     Subnet;
    LonByte     Node;       /* node identifier, use LON_RECEIVESN_NODE_* macros */
}
LON_STRUCT_END(LonReceiveSubnetNode);

/*
 *  Typedef: LonReceiveUniqueId
 *  Received 48-bit unique ID (Neuron ID) destination address.
 *
 *  Used with <LonReceiveDestination>.
 *  Previously named RcvNrnid.
 */
typedef LON_STRUCT_BEGIN(LonReceiveUniqueId)
{
    LonSubnetId Subnet;
    LonUniqueId UniqueId;
}
LON_STRUCT_END(LonReceiveUniqueId);

/*
 *  Typedef: LonReceiveGroup
 *  Received a group destination address.
 *
 *  Used with <LonReceiveDestination>.
 */
typedef LON_STRUCT_BEGIN(LonReceiveGroup)
{
    LonGroupId  GroupId;             /* 0..255 */
}
LON_STRUCT_END(LonReceiveGroup);

/*
 *  Typedef: LonReceiveBroadcast
 *  Received a broadcast destination address.
 *
 *  Used with <LonReceiveDestination>.
 */
typedef LON_STRUCT_BEGIN(LonReceiveBroadcast)
{
    LonSubnetId SubnetId;       /* 1..255 for subnet broadcast, zero for domain broadcast */
}
LON_STRUCT_END(LonReceiveBroadcast);

/*
 *  Typedef: LonReceiveDestination
 *  Union of all possible address formats for receiving an incoming message.
 *
 *  Previously named RcvDestAddr.
 */
typedef LON_UNION_BEGIN(LonReceiveDestination)
{
    LonReceiveBroadcast     Broadcast;
    LonReceiveGroup         Group;
    LonReceiveSubnetNode    SubnetNode;
    LonReceiveUniqueId      UniqueId;
}
LON_UNION_END(LonReceiveDestination);

/*
 *  Enumeration: LonReceiveDestinationAddressFormat
 *  Encodes the format of the receive address.
 *
 *  This enumeration encodes the format of the receive address of an incoming message,
 *  allowing to select the corresponding member in <LonReceiveDestinationAddress>.
 *  Previously named RcvDstAddrFormat.
 */
typedef LON_ENUM_BEGIN(LonReceiveDestinationAddressFormat)
{
    /*  0 */ LonReceiveDestinationAddressBroadcast  = 0,
    /*  1 */ LonReceiveDestinationAddressGroup,
    /*  2 */ LonReceiveDestinationAddressSubnetNode,
    /*  3 */ LonReceiveDestinationAddressUniqueId,
    /*  4 */ LonReceiveDestinationAddressTurnaround
}
LON_ENUM_END(LonReceiveDestinationAddressFormat);

/*
 *  Typedef: LonReceiveAddress
 *  Receive destination and source address for incoming messages.
 *
 *  This structure holds the receive destination address of an incoming message
 *  (the address through which the message was received on this node) and the message's
 *  source address (where it came from).
 *  Previously named RcvAddrDtl.
 */
#define LON_RECEIVEADDRESS_DOMAIN_MASK      0x80    /* domain table index through which the message was received */
#define LON_RECEIVEADDRESS_DOMAIN_SHIFT     7
#define LON_RECEIVEADDRESS_DOMAIN_FIELD     DomainFormat

#define LON_RECEIVEADDRESS_FLEX_MASK        0x40    /* one for flex domain, that is, recieved message on unconfigured node */
#define LON_RECEIVEADDRESS_FLEX_SHIFT       6
#define LON_RECEIVEADDRESS_FLEX_FIELD       DomainFormat

#define LON_RECEIVEADDRESS_FORMAT_MASK      0x3F    /* use LonReceiveDestinationAddressFormat enumeration */
#define LON_RECEIVEADDRESS_FORMAT_SHIFT     0
#define LON_RECEIVEADDRESS_FORMAT_FIELD     DomainFormat

typedef LON_STRUCT_BEGIN(LonReceiveAddress)
{
    LonByte                 DomainFormat;   /* contains domain, flexDomain, format. Use LON_RECEIVEADDRESS_* macros to access data */
    LonReceiveSubnetNode    Source;
    LonReceiveDestination   Destination;
}
LON_STRUCT_END(LonReceiveAddress);

/*
 *  Typedef: LonResponseSource
 *  Source address of a response message
 *
 *  LonResponseSource holds the source address of a response message.
 *  Previously named RespSrcAddr.
 */
#define LON_RESPONSESOURCE_IS_SUBNETNODE_MASK   0x80    /* 1: subnet/node response. 0: group response */
#define LON_RESPONSESOURCE_IS_SUBNETNODE_SHIFT  7
#define LON_RESPONSESOURCE_IS_SUBNETNODE_FIELD  Node

#define LON_RESPONSESOURCE_NODE_MASK     0x7F    /* Node ID of response source */
#define LON_RESPONSESOURCE_NODE_SHIFT    0
#define LON_RESPONSESOURCE_NODE_FIELD    Node

typedef LON_STRUCT_BEGIN(LonResponseSource)
{
    LonByte Subnet;     /* subnet ID */
    LonByte Node;       /* contains node, isNode. Use LON_RESPONSESOURCE_NODE_* and LON_RESPONSESOURCE_IS_SUBNETNODE_* macros */
}
LON_STRUCT_END(LonResponseSource);

/*
 *  Typedef: LonResponseSubnetNode
 *  Destination of response to unicast request.
 *
 *  Used with <LonResponseDestination>.
 *  Previously named RespSnode.
 */

/*
 * Use the LON_RESPONSESN_NODE_* macros to access the LonReceiveSubnetNode.Node field
 */
#define LON_RESPONSESN_NODE_MASK  0x7F    /* node ID 0..127, MSB is reserved */
#define LON_RESPONSESN_NODE_SHIFT 0
#define LON_RESPONSESN_NODE_FIELD Node

typedef LON_STRUCT_BEGIN(LonResponseSubnetNode)
{
    LonSubnetId Subnet;         /* subnet ID */
    LonByte     Node;           /* node ID, use LON_RESPONSESN_NODE_* macros */
}
LON_STRUCT_END(LonResponseSubnetNode);

/*
 *  Typedef: LonResponseGroup
 *  Destination of response to multicast request.
 *
 *  Used with <LonResponseDestination>.
 *  Previously named RespGroup.
 */

/*
 * Use the LON_RESPONSESN_NODE_* macros to access the LonReceiveSubnetNode.Node field
 */
#define LON_RESPGROUP_NODE_MASK     0x7F    /* node ID 0..127, MSB is reserved */
#define LON_RESPGROUP_NODE_SHIFT    0
#define LON_RESPGROUP_NODE_FIELD    Node

#define LON_RESPGROUP_MEMBER_MASK   0x3F
#define LON_RESPGROUP_MEMBER_SHIFT  0
#define LON_RESPGROUP_MEMBER_FIELD  Member

typedef LON_STRUCT_BEGIN(LonResponseGroup)
{
    LonSubnetId Subnet;         /* subnet ID */
    LonByte     Node;
    LonByte     Group;
    LonByte     Member;         /* use LON_RESPGROUP_MEMBER_* macros for access */
}
LON_STRUCT_END(LonResponseGroup);

/*
 *  Typedef: LonResponseDestination
 *  Destination of a response.
 *
 *  Previously named RespDestAddr.
 */
typedef LON_UNION_BEGIN(LonResponseDestination)
{
    LonResponseSubnetNode   SubnetNode;
    LonResponseGroup        Group;
}
LON_UNION_END(LonResponseDestination);

/*
 *  Typedef: LonResponseAddress
 *  Address of incoming response.
 *
 *  Previously named RespAddrDtl.
 */
#define LON_RESPONSEADDRESS_DOMAIN_MASK     0x80    /* domain index, zero or one */
#define LON_RESPONSEADDRESS_DOMAIN_SHIFT    7
#define LON_RESPONSEADDRESS_DOMAIN_FIELD    Domain

#define LON_RESPONSEADDRESS_FLEX_MASK       0x40    /* 1: response from alien domain */
#define LON_RESPONSEADDRESS_FLEX_SHIFT      6
#define LON_RESPONSEADDRESS_FLEX_FIELD      Domain

typedef LON_STRUCT_BEGIN(LonResponseAddress)
{
    LonByte                 Domain;         /* contains domain, flexDomain. Use LON_RESPONSEADDRESS_* macros */
    LonResponseSource       Source;
    LonResponseDestination  Destination;
}
LON_STRUCT_END(LonResponseAddress);

/*
 * Typedef: LonExplicitAddress
 * Holds explicit addressing details, if enabled.
 *
 * LonExplicitAddress holds the address details. To access these fields, support for explicit addressing
 * must be enabled.
 * Previously named ExplicitAddr.
 */
typedef LON_UNION_BEGIN(LonExplicitAddress)
{
    LonReceiveAddress   Receive;
    LonSendAddress      Send;
    LonResponseAddress  Response;
}
LON_UNION_END(LonExplicitAddress);

/*
 * Typedef: LonAddressTableGroup
 * Holds Group addressing information in the address table (<LonAddress>).
 *
 * LonAddressTableGroup holds group addressing data in the address table, used for multicast addressing.
 * This structure also defines which group the node belongs to.
 */
#define LON_ADDRESS_GROUP_TYPE_MASK     0x80    /* 1 -> group   */
#define LON_ADDRESS_GROUP_TYPE_SHIFT    7
#define LON_ADDRESS_GROUP_TYPE_FIELD    TypeSize

#define LON_ADDRESS_GROUP_SIZE_MASK     0x7F    /* group size 1..63, or zero for open group */
#define LON_ADDRESS_GROUP_SIZE_SHIFT    0
#define LON_ADDRESS_GROUP_SIZE_FIELD    TypeSize

#define LON_ADDRESS_GROUP_DOMAIN_MASK   0x80    /* domain index */
#define LON_ADDRESS_GROUP_DOMAIN_SHIFT  7
#define LON_ADDRESS_GROUP_DOMAIN_FIELD  DomainMember

#define LON_ADDRESS_GROUP_MEMBER_MASK   0x7F
#define LON_ADDRESS_GROUP_MEMBER_SHIFT  0
#define LON_ADDRESS_GROUP_MEMBER_FIELD  DomainMember

#define LON_ADDRESS_GROUP_REPEAT_TIMER_MASK     0xF0    /* repeat timer, use LonRepeatTimer */
#define LON_ADDRESS_GROUP_REPEAT_TIMER_SHIFT    4
#define LON_ADDRESS_GROUP_REPEAT_TIMER_FIELD    RepeatRetry

#define LON_ADDRESS_GROUP_RETRY_MASK    0x0F        /* retry count */
#define LON_ADDRESS_GROUP_RETRY_SHIFT   0
#define LON_ADDRESS_GROUP_RETRY_FIELD   RepeatRetry

#define LON_ADDRESS_GROUP_RECEIVE_TIMER_MASK    0xF0   /* receive timer, use LonReceiveTimer */
#define LON_ADDRESS_GROUP_RECEIVE_TIMER_SHIFT   4
#define LON_ADDRESS_GROUP_RECEIVE_TIMER_FIELD   ReceiveTransmit

#define LON_ADDRESS_GROUP_TRANSMIT_TIMER_MASK   0x0F  /* transmit timer, use LonTransmitTimer */
#define LON_ADDRESS_GROUP_TRANSMIT_TIMER_SHIFT  0
#define LON_ADDRESS_GROUP_TRANSMIT_TIMER_FIELD  ReceiveTransmit

typedef LON_STRUCT_BEGIN(LonAddressTableGroup)
{
    LonByte     TypeSize;               /* contains type, size. Use the LON_ADDRESS_GROUP_* macros */
    LonByte     DomainMember;           /* contains domain, member. Use the LON_ADDRESS_GROUP_* macros */
    LonByte     RepeatRetry;            /* contains repeatTimer, retry. Use the LON_ADDRESS_GROUP_* macros */
    LonByte     ReceiveTransmit;        /* contains receive and transmit timer. Use Lon_ADDRESS_GROUP_* macros */
    LonGroupId  Group;                  /* the group identifier */
}
LON_STRUCT_END(LonAddressTableGroup);

/*
 *  Typedef: LonAddressTableSubnetNode
 *  Holds subnet/node addressing information in the address table (<LonAddress>).
 *
 *  LonAddressTableSubnetNode holds subnet/node address information in the address table (<LonAddress>), used for
 *  unicast addressing.
 */
#define LON_ADDRESS_SN_DOMAIN_MASK      0x80        /* domain index */
#define LON_ADDRESS_SN_DOMAIN_SHIFT     7
#define LON_ADDRESS_SN_DOMAIN_FIELD     DomainNode

#define LON_ADDRESS_SN_NODE_MASK        0x7F        /* node ID */
#define LON_ADDRESS_SN_NODE_SHIFT       0
#define LON_ADDRESS_SN_NODE_FIELD       DomainNode

#define LON_ADDRESS_SN_REPEAT_TIMER_MASK    0xF0    /* repeat timer, use LonRepeatTimer */
#define LON_ADDRESS_SN_REPEAT_TIMER_SHIFT   4
#define LON_ADDRESS_SN_REPEAT_TIMER_FIELD   RepeatRetry

#define LON_ADDRESS_SN_RETRY_MASK       0x0F        /* retry count */
#define LON_ADDRESS_SN_RETRY_SHIFT      0
#define LON_ADDRESS_SN_RETRY_FIELD      RepeatRetry

typedef LON_STRUCT_BEGIN(LonAddressTableSubnetNode)
{
    LON_ENUM(LonAddressType)    Type;           /* should be LonAddressSubnetNode   */
    LonByte                     DomainNode;     /* contains domain, node. Use LON_ADDRESS_SN_* macros */
    LonByte                     RepeatRetry;    /* contains repeat timer and retry. Use LON_ADDRESS_SN_* macros */
    LON_ENUM(LonTransmitTimer)  TransmitTimer;
    LonSubnetId                 Subnet;
}
LON_STRUCT_END(LonAddressTableSubnetNode);

/*
 *  Typedef: LonAddressTableBroadcast
 *  Holds broadcast addressing information in the address table (<LonAddress>).
 *
 *  LonAddressTableBroadcast holds broadcast addressing information in the address table (<LonAddress>), used for
 *  multicast accressing.
 */
#define LON_ADDRESS_BROADCAST_DOMAIN_MASK   0x80        /* domain index */
#define LON_ADDRESS_BROADCAST_DOMAIN_SHIFT  7
#define LON_ADDRESS_BROADCAST_DOMAIN_FIELD  DomainBacklog

#define LON_ADDRESS_BROADCAST_BACKLOG_MASK  0x3F        /* backlog. Use zero if unknown */
#define LON_ADDRESS_BROADCAST_BACKLOG_SHIFT 0
#define LON_ADDRESS_BROADCAST_BACKLOG_FIELD DomainBacklog

#define LON_ADDRESS_BROADCAST_REPEAT_TIMER_MASK 0xF0    /* repeat timer, use LonRepeatTimer */
#define LON_ADDRESS_BROADCAST_REPEAT_SHIFT      4
#define LON_ADDRESS_BROADCAST_REPEAT_FIELD      RepeatRetry

#define LON_ADDRESS_BROADCAST_RETRY_MASK    0x0F        /* retry counts */
#define LON_ADDRESS_BROADCAST_RETRY_SHIFT   0
#define LON_ADDRESS_BROADCAST_RETRY_FIELD   RepeatRetry

typedef LON_STRUCT_BEGIN(LonAddressTableBroadcast)
{
    LON_ENUM(LonAddressType)    Type;           /* should be LonAddressBroadcast */
    LonByte                     DomainBacklog;  /* contains domain, backlog. Use LON_ADDRESS_BROADCAST_* macros */
    LonByte                     RepeatRetry;    /* contains repeat timer and retry. Use LON_ADDRESS_BROADCAST_* macros instead */
    LON_ENUM(LonTransmitTimer)  TransmitTimer;
    LonSubnetId                 Subnet;
}
LON_STRUCT_END(LonAddressTableBroadcast);

/*
 *  Typedef: LonAddressTableTurnaround
 *  Holds turnaround address information in the address table (<LonAddress>).
 */
#define LON_ADDRESS_TURNAROUND_REPEAT_TIMER_MASK    0xF0    /* use LonRepeatTimer */
#define LON_ADDRESS_TURNAROUND_REPEAT_TIMER_SHIFT   4
#define LON_ADDRESS_TURNAROUND_REPEAT_TIMER_FIELD   RepeatRetry

#define LON_ADDRESS_TURNAROUND_RETRY_MASK           0x0F    /* retry count */
#define LON_ADDRESS_TURNAROUND_RETRY_SHIFT          0
#define LON_ADDRESS_TURNAROUND_RETRY_FIELD          RepeatRetry

typedef LON_STRUCT_BEGIN(LonAddressTableTurnaround)
{
    LON_ENUM(LonAddressType)    Type;           /* should be LonAddressTurnaround */
    LonByte                     Turnaround;     /* 1: turnaround record. 0: not in use */
    LonByte                     RepeatRetry;    /* contains repeat timer and retry. Use LON_ADDRESS_TURNAROUND_* macros */
    LON_ENUM(LonTransmitTimer)  TransmitTimer;
}
LON_STRUCT_END(LonAddressTableTurnaround);

/*
 * ******************************************************************************
 * SECTION: SYSTEM STRUCTURES
 * ******************************************************************************
 *
 *  This section contains definitions of system resources and structures, such as
 *  the domain table or address table formats, and so on.
 */

/*
 *  Typedef: LonAddress
 *  Describes one record of the address table.
 */
typedef LON_UNION_BEGIN(LonAddress)
{
    LonAddressTableGroup        Group;
    LonAddressTableSubnetNode   SubnetNode;
    LonAddressTableBroadcast    Broadcast;
    LonAddressTableTurnaround   Turnaround;
}
LON_UNION_END(LonAddress);

/*
 *  Enumeration: LonDomainLength
 *  Encodes the length of the domain.
 *
 *  This enumeration encodes the length of the domain.
 */
typedef LON_ENUM_BEGIN(LonDomainLength)
{
    /*  0 */ LonDomainLength_0  = 0,
    /*  1 */ LonDomainLength_1  = 1,
    /*  3 */ LonDomainLength_3  = 3,
    /*  6 */ LonDomainLength_6  = 6
}
LON_ENUM_END(LonDomainLength);

/*
 *  Enumeration: LonAuthenticationType
 *  Denotes the authentication type, used with <LonDomain>.
 *
 *  This enumeration encodes the authentication type. Use with
 *  the LON_DOMAIN_AUTHTYPE_* symbols and the <LonDomain> type.
 */
typedef LON_ENUM_BEGIN(LonAuthenticationType)
{
    /*  0 */ LonAuthenticationType_STD  = 0,
    /*  1 */ LonAuthenticationType_OMA  = 1
}
LON_ENUM_END(LonAuthenticationType);

/*
 *  Typedef: LonDomain
 *  Format for a single domain table record.
 *
 *  Previously named domain_struct.
 */
#define LON_DOMAIN_NONCLONE_MASK    0x80
#define LON_DOMAIN_NONCLONE_SHIFT   7
#define LON_DOMAIN_NONCLONE_FIELD   NodeClone

#define LON_DOMAIN_NODE_MASK        0x7F
#define LON_DOMAIN_NODE_SHIFT       0
#define LON_DOMAIN_NODE_FIELD       NodeClone

#define LON_DOMAIN_INVALID_MASK     0x80
#define LON_DOMAIN_INVALID_SHIFT    7
#define LON_DOMAIN_INVALID_FIELD    InvalidIdLength

#define LON_DOMAIN_AUTHTYPE_MASK    0x18
#define LON_DOMAIN_AUTHTYPE_SHIFT   3
#define LON_DOMAIN_AUTHTYPE_FIELD   InvalidIdLength

#define LON_DOMAIN_ID_LENGTH_MASK   0x07
#define LON_DOMAIN_ID_LENGTH_SHIFT  0
#define LON_DOMAIN_ID_LENGTH_FIELD  InvalidIdLength

typedef LON_STRUCT_BEGIN(LonDomain)
{
    LonDomainId             Id;
    LonSubnetId             Subnet;
    LonByte                 NodeClone;          /* contains nonclone, node. Use LON_DOMAIN_* macros */
    LonByte                 InvalidIdLength;    /* use LON_DOMAIN_INVALID_* and LON_DOMAIN_ID_LENGTH_* macros. Also denotes authentication type; see LON_DOMAIN_AUTHTYPE_* */
    LonAuthenticationKey    Key;
}
LON_STRUCT_END(LonDomain);

/*
 *  Typedef: LonNvConfig
 *  The network variable configuration structure.
 *
 *  IzoT ShortStack expands this data structure with additional fields,
 *  required to support an extended address table (EAT). The API always
 *  presents this form of the network variable configuration structure,
 *  and automatically translates back to the legacy format when used
 *  with a Micro Server which does not support EAT.
 *  The LonNvConfigNonEat type, defined below, is strictly for internal
 *  use within the API implementation.
 */
#define LON_NV_PRIORITY_MASK    0x80        /* use LonBool */
#define LON_NV_PRIORITY_SHIFT   7
#define LON_NV_PRIORITY_FIELD   SelhiDirPrio

#define LON_NV_OUTPUT_MASK      0x40
#define LON_NV_OUTPUT_SHIFT     6
#define LON_NV_OUTPUT_FIELD     SelhiDirPrio

#define LON_NV_SELHIGH_MASK     0x3F
#define LON_NV_SELHIGH_SHIFT    0
#define LON_NV_SELHIGH_FIELD    SelhiDirPrio

#define LON_NV_TURNAROUND_MASK  0x80        /* use LonBool */
#define LON_NV_TURNAROUND_SHIFT 7
#define LON_NV_TURNAROUND_FIELD Attributes

#define LON_NV_SERVICE_MASK     0x60        /* use LonServiceType */
#define LON_NV_SERVICE_SHIFT    5
#define LON_NV_SERVICE_FIELD    Attributes

#define LON_NV_AUTHENTICATION_MASK  0x10    /* use LonBool */
#define LON_NV_AUTHENTICATION_SHIFT 4
#define LON_NV_AUTHENTICATION_FIELD Attributes

#define LON_NV_ADDRESS_MASK     0x0F
#define LON_NV_ADDRESS_SHIFT    0
#define LON_NV_ADDRESS_FIELD    Attributes

#define LON_NV_ADDRHIGH_MASK    0xF0
#define LON_NV_ADDRHGIH_SHIFT   4
#define LON_NV_ADDRHIGH_FIELD   Attributes2

typedef LON_STRUCT_BEGIN(LonNvConfig)
{
    LonByte     SelhiDirPrio;   /* contains selectorHigh, direction (input or output), priority. Use LON_NV_* macros */
    LonByte     SelectorLow;
    LonByte     Attributes;     /* contains turnaround, service, authentication, and address table index. Use LON_NV_* macros */
    LonByte     Attributes2;    /* contains address index (high nibble) and 4 reserved bits (must be zero) */
}
LON_STRUCT_END(LonNvConfig);

typedef LON_STRUCT_BEGIN(LonNvConfigNonEat)
{
    LonByte     SelhiDirPrio;   /* contains selectorHigh, direction (input or output), priority. Use LON_NV_* macros */
    LonByte     SelectorLow;
    LonByte     Attributes;     /* contains turnaround, service, authentication, and address table index. Use LON_NV_* macros */
}
LON_STRUCT_END(LonNvConfigNonEat);

/*
 *  Typedef: LonAliasConfig
 *  Defines a network variable alias table record.
 *
 *  IzoT ShortStack expands this data structure with additional fields,
 *  required to support an extended address table (EAT). The API always
 *  presents this form of the network variable alias data structure,
 *  and automatically translates back to the legacy format when used
 *  with a Micro Server which does not support EAT.
 *  The LonAliasConfigNonEat type, defined below, is strictly for internal
 *  use within the API implementation.
 */
typedef LON_STRUCT_BEGIN(LonAliasConfig)
{
    LonNvConfig     Alias;
    LonByte         Primary;
    LonWord         HostPrimary;   /* iff primary is 0xFF */
}
LON_STRUCT_END(LonAliasConfig);

typedef LON_STRUCT_BEGIN(LonAliasConfigNonEat)
{
    LonNvConfigNonEat Alias;
    LonByte         Primary;
    LonWord         HostPrimary;   /* iff primary is 0xFF */
}
LON_STRUCT_END(LonAliasConfigNonEat);

/*
 *  Typedef: LonDirectModeTransceiver
 *  Holds direct-mode transceiver parameters.
 *
 *  Previously named direct_param_struct.
 */
#define LON_DIRECT_XCVR_CD_MASK             0x80    /* collission-detect */
#define LON_DIRECT_XCVR_CD_SHIFT            7
#define LON_DIRECT_XCVR_CD_FIELD            Parameter_1

#define LON_DIRECT_XCVR_BST_MASK            0x60    /* bit-sync-threshold */
#define LON_DIRECT_XCVR_BST_SHIFT           5
#define LON_DIRECT_XCVR_BST_FIELD           Parameter_1

#define LON_DIRECT_XCVR_FILTER_MASK         0x18    /* filter */
#define LON_DIRECT_XCVR_FILTER_SHIFT        3
#define LON_DIRECT_XCVR_FILTER_FIELD        Parameter_1

#define LON_DIRECT_XCVR_HYSTERESIS_MASK     0x07    /* hysteresis */
#define LON_DIRECT_XCVR_HYSTERESIS_SHIFT    0
#define LON_DIRECT_XCVR_HYSTERESIS_FIELD    Parameter_1

#define LON_DIRECT_XCVR_CDTEP_MASK          0xFC    /* CD to end packet */
#define LON_DIRECT_XCVR_CDTEP_SHIFT         2
#define LON_DIRECT_XCVR_CDTEP_FIELD         Parameter_2

#define LON_DIRECT_XCVR_CDTAIL_MASK         0x02    /* CD tail */
#define LON_DIRECT_XCVR_CDTAIL_SHIFT        1
#define LON_DIRECT_XCVR_CDTAIL_FIELD        Parameter_2

#define LON_DIRECT_XCVR_CDPREAMBLE_MASK     0x01    /* CD preamble */
#define LON_DIRECT_XCVR_CDPREAMBLE_SHIFT    0
#define LON_DIRECT_XCVR_CDPREAMBLE_FIELD    Parameter_2

typedef LON_STRUCT_BEGIN(LonDirectModeTransceiver)
{
    LonByte      Parameter_1;    /* contains collission-detect, bit-sync-threshold, filter, and hysteresis. Use LON_DIRECT_XCVR_* macros */
    LonByte      Parameter_2;    /* contains cd-to-end-packet, cd-tail, cd-preamble. Use LON_DIRECT_XCVR_* macros */
}
LON_STRUCT_END(LonDirectModeTransceiver);

/*
 *  Typedef: LonConfigData
 *  The configuration data structure.
 *
 *  Previously named config_data_struct.
 */
#define LON_CONFIG_COMM_CLOCK_MASK      0xF8    /* communications clock rate */
#define LON_CONFIG_COMM_CLOCK_SHIFT     3
#define LON_CONFIG_COMM_CLOCK_FIELD     Clock

#define LON_CONFIG_INPUT_CLOCK_MASK     0x07    /* input clock */
#define LON_CONFIG_INPUT_CLOCK_SHIFT    0
#define LON_CONFIG_INPUT_CLOCK_FIELD    Clock

#define LON_CONFIG_COMM_TYPE_MASK       0xE0    /* communications type */
#define LON_CONFIG_COMM_TYPE_SHIFT      5
#define LON_CONFIG_COMM_TYPE_FIELD      CommConfiguration

#define LON_CONFIG_COMM_PINDIR_MASK     0x1F    /* pin direction */
#define LON_CONFIG_COMM_PINDIR_SHIFT    0
#define LON_CONFIG_COMM_PINDIR_FIELD    CommConfiguration

#define LON_CONFIG_NONGRPRCV_MASK       0xF0    /* non-group receive timer, use <LonNonGroupReceiveTimer> */
#define LON_CONFIG_NONGRPRCV_SHIFT      4
#define LON_CONFIG_NONGRPRCV_FIELD      Config_1

#define LON_CONFIG_NMAUTH_MASK          0x08    /* network management authentication */
#define LON_CONFIG_NMAUTH_SHIFT         3
#define LON_CONFIG_NMAUTH_FIELD         Config_1

#define LON_CONFIG_PREEMPT_MASK         0x07    /* pre-emption timeout */
#define LON_CONFIG_PREEMPT_SHIFT        0
#define LON_CONFIG_PREEMPT_FIELD        Config_1

typedef LON_STRUCT_BEGIN(LonConfigData)
{
    LonWord         ChannelId;
    LonLocationId   Location;
    LonByte         Clock;              /* Input clock and communications clock; use LON_CONFIG_* macros */
    LonByte         CommConfiguration;  /* Communications type and pin direction; use LON_CONFIG_* macros */
    LonByte         PreambleLength;     /* Length of the preamble for Direct mode; set to zero for all other modes */
    LonByte         PacketCycle;        /* Packet cycle duration used for counting down the backlog */
    LonByte         Beta2Control;       /* Beta 2 slot width */
    LonByte         TransmitInterpacket;/* Interpacket padding after transmitting */
    LonByte         ReceiveInterpacket; /* Interpacket padding after receiving */
    LonByte         NodePriority;       /* Priority slot used by the device when sending priority messages (1 to 255) */
    LonByte         ChannelPriorities;  /* Number of priority slots on the channel (0 to 255) */
    LON_UNION_BEGIN(CommunicationParameters) {
        LonTransceiverParameters    TransceiverParameters;  /* Array of seven transceiver-specific parameters for Special-Purpose mode transceivers */
        LonDirectModeTransceiver    DirectModeParameters;   /* Controls the operation of the transceiver port for direct mode transceivers */
    }
    LON_UNION_END(CommunicationParameters);
    LonByte         Config_1;           /* Pre-emption timeout, network management authentication flag, and non-group receive timer; use LON_CONFIG_* macros */
}
LON_STRUCT_END(LonConfigData);

/*
 *  Typedef: LonStatus
 *  Holds node status and statistics.
 *
 *  Previously named status_struct.
 */
typedef LON_STRUCT_BEGIN(LonStatus)
{
    LonWord                     TransmitErrors;
    LonWord                     TransactionTimeouts;
    LonWord                     ReceiveTransactionsFull;
    LonWord                     LostMessages;
    LonWord                     MissedMessages;
    LON_ENUM(LonResetCause)     ResetCause;
    LON_ENUM(LonNodeState)      NodeState;
    LonByte                     VersionNumber;
    LON_ENUM(LonSystemError)    ErrorLog;
    LON_ENUM(LonNeuronModel)    ModelNumber;
}
LON_STRUCT_END(LonStatus);

/*
 * ******************************************************************************
 * SECTION: MESSAGE CODES
 * ******************************************************************************
 *
 *  This section defines message codes and utilities for dealing with message codes.
 */

/*
 *  Enumeration: LonNmMessageCode
 *  Message codes for network management and diagnostic classes of messages
 *
 *  Previously named NM_message_code.
 */
typedef LON_ENUM_BEGIN(LonNmMessageCode)
{
    /* codes for network diagnostic commands */
    LonNdQueryStatus                   = 0x51,
    LonNdProxy                         = 0x52,
    LonNdClearStatus                   = 0x53,
    LonNdQueryXcvr                     = 0x54,
    LonNdQueryStatusFlexDomain         = 0x56,

    /* codes for network management commands */
    LonNmExpanded                      = 0x60,
    LonNmQueryId                       = 0x61,
    LonNmRespondToQuery                = 0x62,
    LonNmUpdateDomain                  = 0x63,
    LonNmLeaveDomain                   = 0x64,
    LonNmUpdateKey                     = 0x65,
    LonNmUpdateAddr                    = 0x66,
    LonNmQueryAddr                     = 0x67,
    LonNmQueryNvConfig                 = 0x68,
    LonNmUpdateGroupAddr               = 0x69,
    LonNmQueryDomain                   = 0x6A,
    LonNmUpdateNvConfig                = 0x6B,
    LonNmSetNodeMode                   = 0x6C,
    LonNmReadMemory                    = 0x6D,
    LonNmWriteMemory                   = 0x6E,
    LonNmChecksumRecalculation         = 0x6F,
    LonNmWink                          = 0x70,
    LonNmInstall                       = LonNmWink, /* See <LonInstallCommand> */
    LonNmAppCommand                    = LonNmWink,
    LonNmMemoryRefresh                 = 0x71,
    LonNmQuerySiData                   = 0x72,
    LonNmQuerySnvt                     = LonNmQuerySiData,
    LonNmNvFetch                       = 0x73,
    LonNmDeviceEscape                  = 0x7D,
    LonNmRouterEscape                  = 0x7E,
    LonNmServicePin                    = 0x7F
}
LON_ENUM_END(LonNmMessageCode);

/*
 *  Enumeration: LonInstallCommand
 *  Extended installation commands for devices that use SI data version 2. SI
 *  data version 2 is required for any device that supports dynamic network
 *  variables. Used by <LonNmInstallRequest>.
 */
typedef LON_ENUM_BEGIN(LonInstallCommand)
{
    LonInstallWink              = 0,    /* Basic application wink                     */
    LonInstallQueryNvInfo       = 4,    /* Query network variable information         */
    LonInstallQueryNodeInfo     = 5     /* Query node self-documentation information  */
}
LON_ENUM_END(LonInstallCommand);

/*
 *  Enumeration: LonNvInfoType
 *  Types of network variable information that can be queried using
 *  *LonInstallQueryNvInfo. Used by <LonNmInstallRequest> when *Command* is
 *  set to *LonInstallQueryNvInfo*.
 */
typedef LON_ENUM_BEGIN(LonNvInfoType)
{
    LonNvInfoDescriptor         = 0,    /* Query NV description (LonNmInstallResponse.NvDescriptor) */
    LonNvInfoRateEstimate       = 1,    /* Query NV rate estimates (LonNmInstallResponse.NvRate) */
    LonNvInfoName               = 2,    /* Query NV Name (LonNmInstallResponse.NvName) */
    LonNvInfoSdText             = 3,    /* Query NV self-documentation string (LonNmInstallResponse.NvSd) */
    LonNvInfoSnvtIndex          = 4     /* Query NV SNVT index (LonNmInstallResponse.SnvtTypeIndex) */
}
LON_ENUM_END(LonNvInfoType);

/*
 *  Enumeration: LonExpSubcommand
 *  Subcommand codes when *Command* is LonNmExpanded.
 */
typedef LON_ENUM_BEGIN(LonExpSubcommand)
{
    LonExpUpdateNvConfig = 0x11, /* Update NV config table with EAT support */
    LonExpQueryNvConfig = 0x12,  /* Query NV config table with EAT support */
    LonExpUpdateAliasConfig = 0x13, /* Update alias table with EAT support */
    LonExpQueryAliasConfig = 0x14   /* Query alias table with EAT support */
}
LON_ENUM_END(LonExpSubcommand);

/*
 *  Enumeration: LonNodeInfoType
 *  Types of node information that can be queried using *LonInstallQueryNodeInfo*.
 *  Used by <LonNmInstallRequest> when *Command* is set to
 *  *LonInstallQueryNodeInfo*.
 */
typedef LON_ENUM_BEGIN(LonNodeInfoType)
{
    LonNodeInfoSdText             = 3     /* Query node self-documentation string (LonNmInstallResponse.NodeSd) */
}
LON_ENUM_END(LonNodeInfoType);

/*
 *  Enumeration: LonNvOrigin
 *  Defines the origins of a network variable.  Use the LON_NV_DESC_ORIGIN_*
 *  macros with the <LonNmInstallResponse> union.
 */
typedef LON_ENUM_BEGIN(LonNvOrigin)
{
    LonNvOriginUndefined    = 0,    /* Not currently defined */
    LonNvOriginStatic       = 1,    /* Statically defined     */
    LonNvOriginDynamic      = 2     /* Dynamically defined     */
}
LON_ENUM_END(LonNvOrigin);

/*
 *  Macro: LON_NM_FAILURE
 *  Failure response codes for network management and diagnostic classes of messages.
 */
#define LON_NM_FAILURE(c)            ((c) & 0x1F)

/*
 *  Macro: LON_NM_SUCCESS
 *  Success response codes for network management and diagnostic classes of messages.
 */
#define LON_NM_SUCCESS(c)            (LON_NM_FAILURE(c) | 0x20)

/*
 *  The following LON_NM_* and LON_ND_* macros define offsets and masks for constructing
 *  request and response codes
 */
#define LON_NM_OPCODE_BASE      0x60
#define LON_NM_OPCODE_MASK      0x1F
#define LON_NM_RESPONSE_MASK    0xE0
#define LON_NM_RESPONSE_SUCCESS 0x20
#define LON_NM_RESPONSE_FAILED  0x00

#define LON_ND_OPCODE_BASE      0x50
#define LON_ND_OPCODE_MASK      0x0F
#define LON_ND_RESPONSE_MASK    0xF0
#define LON_ND_RESPONSE_SUCCESS 0x30
#define LON_ND_RESPONSE_FAILED  0x10

/*
 * Message 'tag' for a ShortStack local network
 * management/Diagnose message is always 0x0F
 */
#define NM_ND_TAG   0x0F

/*
 *  Typedef: LonCorrelator
 *  Data structure used for correlating requests and repsonses.
 *
 *  LonCorrelator is used to correlate request messages and their responses.
 */

#define LON_CORRELATOR_PRIORITY_MASK    0x80
#define LON_CORRELATOR_PRIORITY_SHIFT   7
#define LON_CORRELATOR_PRIORITY_FIELD   Attributes

#define LON_CORRELATOR_SERVICE_MASK     0x60
#define LON_CORRELATOR_SERVICE_SHIFT    5
#define LON_CORRELATOR_SERVICE_FIELD    Attributes

#define LON_CORRELATOR_TAG_MASK         0x0F
#define LON_CORRELATOR_TAG_SHIFT        0
#define LON_CORRELATOR_TAG_FIELD        Attributes

typedef struct {
    LonByte     Attributes; /* Contains Priority, ServiceType, Tag. Use LON_CORRELATOR_* macros */
} LonCorrelator;

/*
 * ******************************************************************************
 * SECTION: APPLICATION BUFFER STRUCTURES
 * ******************************************************************************
 *
 * This section details the application buffer structures for sending and receiving
 * messages to and from a network interface.
 * These structures have up to two parts: the two-byte network interface command, and
 * the optional message payload with the data.
 *
 * Network Interface Command (LonSmipHdr): The network interface command is always present.
 * It contains the network interface command and queue specifier.  This is the only field
 * required for most local network interface commands.
 *
 * Data (LonMessageData: LonNiResetPayload, LonNiSidataPayload, or union of
 * LonExplicitMessage and LonNvMessage)
 */

/*
 ****************************************************************************
 * Network Interface Command data structure.  This is the application-layer
 * header used for all messages to and from a LONWORKS network interface.
 ****************************************************************************
 */

/*
 *  Enumeration: LonSmipQueue
 *  Literals for the queue specifier in <LonSmipHdr>.
 *
 *  The queue specifier is OR'ed with the <LonSmipCmd> for the LonNiComm and LonNiNetManagement
 *  commands, and used with the command field of the <LonSmipHdr> preamble.
 */
typedef LON_ENUM_BEGIN(LonSmipQueue)
{
    LonNiTxQueue            =  2,             /* Transaction queue                        */
    LonNiTxQueuePriority    =  3,             /* Priority transaction queue               */
    LonNiNonTxQueue         =  4,             /* Non-transaction queue                    */
    LonNiNonTxQueuePriority =  5,             /* Priority non-transaction queue           */
    LonNiResponse           =  6,             /* Response msg & completion event queue    */
    LonNiIncoming           =  8              /* Received message queue                   */
}
LON_ENUM_END(LonSmipQueue);

/*
 *  Enumeration: LonSmipCmd
 *  Literals for the 'cmd' byte of <LonSmipHdr>
 *
 *  These commands are used with the command field of the <LonSmipHdr> preamble.
 *  Note that the command field may contain significant bits in addition to the
 *  values defined with this <LonSmipCmd> enumeration. For example, the <LonSmipQueue>
 *  specifier is OR'ed with the LonNiComm and LonNiNetManagement commands. See the definitions
 *  of the individual commands in this enumeration for more.
 */
typedef LON_ENUM_BEGIN(LonSmipCmd)
{
    LonNiNull           = 0x00,
    LonNiXOff           = 0x01,        /* software flow control                    */
    LonNiXOn            = 0x02,
    LonNiService        = 0x06,        /* Uplink: Service pin has been pressed     */
    /* Downlink: to send a service pin message  */
    LonNiAppInit        = 0x08,        /* Downlink, APPINIT command                */
    LonNiSiData         = 0x0A,        /* Downlink, SIDATA command                 */
    LonNiNvInit         = 0x0B,        /* Downlink, NVINIT command                 */
    LonNiServiceHeld    = 0x0B,        /* Uplink, delayed service pin notification command */
    LonNiNascentKey     = 0x0C,        /* Downlink, set nascent key                        */
    LonNiUsop           = 0x0D,        /* Downlink, send an extended local command to Micro Server   */
    LonNiComm           = 0x10,        /* Data transfer to/from network (lower nibble is   */
    /* LonSmipQueue value)                              */
    LonNiNetManagement  = 0x20,        /* Local network management/diagnostics (lower      */
    /* nibble is LonSmipQueue value)                    */
    LonNiPhase          = 0x40,        /* Lower nibble contains phase reading.                                      */
    LonNiReset          = 0x50,        /* Uplink: node resets            */
    /* Downlink: ask node to reset    */
    LonNiFlushComplete  = 0x60,        /* Uplink                         */
    LonNiFlushCancel    = 0x60,        /* Downlink                       */
    LonNiOnLine         = 0x70,        /* Downlink: Ask node go online   */
    LonNiOffLine        = 0x80,        /* Downlink: Ask node go offline  */
    LonNiFlush          = 0x90,        /* Downlink                       */
    LonNiFlushIgnore    = 0xA0,        /* Downlink                       */
    LonNiSleep          = 0xB0,        /* Not supported by ShortStack Micro Server   */

    LonIsiNack          = 0xBC,        /* Uplink: ISI Nack in response to a downlink RPC */
    LonIsiAck           = 0xBD,        /* Uplink: ISI Ack in response to a downlink RPC */
    LonIsiCmd           = 0xBE,        /* Downlink: ISI Downlink RPC */
    /* Uplink: ISI Uplink RPC */

    LonNiNv             = 0xC0         /* Special case for downlink NV updates and polls.
                                       Least significant 6 bits contain NV index. */
}
LON_ENUM_END(LonSmipCmd);

/*
 *  Typedef: LonSmipHdr
 *  Preamble for network interface messages.
 *
 *  The preamble (header) has a length field which specifies the message payload to follow
 *  a network interface command, not including the preamble bytes themselves.
 */
typedef LON_STRUCT_BEGIN(LonSmipHdr)
{
    LonByte                 Length;        /* Length of the data to follow, not including the <LonSmipCmd> preamble */
    LON_ENUM(LonSmipCmd)    Command;       /* Network interface command, possibly OR'ed with additional information (such as the queue identifier) */
}
LON_STRUCT_END(LonSmipHdr);

/*
 *  Typedef: LonSmipExtHdr
 *  An extended header segment, used with some network interface messages.
 *
 *  The info segment is sent after the header and before the payload, each with its own handshake
 *  exchange, with outgoing network variable messages related to network variables with indices
 *  > 61.
 */
typedef LON_STRUCT_BEGIN(LonSmipExtHdr)
{
    LonByte                 Index;
    LonByte                 Reserved;
}
LON_STRUCT_END(LonSmipExtHdr);

/*
 *  Typedef: LonSmipDrvCtrl
 *  Additional control data used by the link layer driver. This data is never sent
 *  or received across the link layer.
 */
typedef LON_STRUCT_BEGIN(LonSmipDrvCtrl)
{
    LonByte                 Data;
}
LON_STRUCT_END(LonSmipDrvCtrl);

/* Maximum data size of SMIP message, excluding hdr   */
/* LON_APP_OUTPUT_BUFSIZE reflects the application    */
/* buffer size on the ShortStack Micro Server. See    */
/* LonDev.h for its definition.                    */
#define LON_SMIP_MAX_DATA (LON_APP_OUTPUT_BUFSIZE - sizeof(LonSmipHdr) - sizeof(LonSmipExtHdr))

/*
 *  Typedef: LonSmipMsg
 *  Data structure superset for all link layer data.
 *  Izot ShortStack 4.30 adds additional data to this structure, not all of which is
 *  exchanged across the link layer.
 *
 *  Note this is a superset structure. Allocating memory for this structure will be sufficient to hold any
 *  link layer packet, but the packet's header must be examined to determine the payload packet structure, and
 *  the packet's actual payload size.
 *
 *  The extended header segment is listed after the payload segment in order to minimize
 *  layout changes caused by the addition of the extended header and driver control segments.
 *  Note that the declaration order here does not reflect the chronological order of segment
 *  transmission.
 *
 *  The driver control data is used and managed by the driver.
 *
 *  The Id number is a quasi-unique identifier for a frame. This is useful to correlate and
 *  identify frame reports in log files for trouble-shooting. The LdvAlloc API assigns a
 *  new number to every newly allocated frame, ignoring overflow errors.
 */
typedef LON_STRUCT_BEGIN(LonSmipMsg)
{
    LonSmipHdr  Header;                         /* message header   */
    LonByte     Payload[LON_SMIP_MAX_DATA];     /* message payload. */
    LonSmipExtHdr   ExtHdr;                     /* extended message header */
    LonSmipDrvCtrl  Ctrl;                       /* driver control data */
    uint16_t        Id;                         /* a quasi-unique Id */
}
LON_STRUCT_END(LonSmipMsg);

/*
 *  Enumeration: LonUsopCmd
 *  Literals for the sub-command byte of LonNiUsop command
 *
 *  These commands are used in the first byte of the LonNiUsop command payload.
 *  Depending upon the sub-command type, additional data can follow.
 */

#define LON_ECHO_SIZE           6              /* size of Echo data */

typedef LON_ENUM_BEGIN(LonUsopCmd)
{
    LonUsopPing                 = 0x01,        /* Ping  */
    LonUsopNvIsBound            = 0x02,        /* Is Bound Nv   */
    LonUsopMtIsBound            = 0x03,        /* Is Bound Mt   */
    LonUsopGoUcfg               = 0x04,        /* Go Unconfigured   */
    LonUsopGoCfg                = 0x05,        /* Go Configured   */
    LonUsopQueryAppSignature    = 0x06,        /* Query App Signature  */
    LonUsopVersion              = 0x07,        /* Query Micro Server version details */
    LonUsopEcho                 = 0x0A,        /* Request Echo */
    LonUsopSetPostResetPause    = 0x0E         /* Set post-reset pause duration */
}
LON_ENUM_END(LonUsopCmd);

/*
 *  Typedef: LonResetNotification
 *  Structure for uplink reset message.
 *
 *  The Micro Server provides an uplink reset notification with every reset.
 *  Previously named LonResetMsg.
 */
#define LON_RESET_STATE_CSERROR_MASK    0x02    /* Use LonBool. True if a checksum error has occurred  */
#define LON_RESET_STATE_CSERROR_SHIFT   1
#define LON_RESET_STATE_CSERROR_FIELD   State

#define LON_RESET_STATE_UNCNFG_MASK     0x01    /* Use LonBool. True if the Micro Server is unconfigured. */
#define LON_RESET_STATE_UNCNFG_SHIFT    0
#define LON_RESET_STATE_UNCNFG_FIELD    State

#define LON_RESET_INITIALIZED_MASK      0x80    /* Set if the Micro Server is initialized. */
#define LON_RESET_INITIALIZED_SHIFT     7
#define LON_RESET_INITIALIZED_FIELD     Flags

#define LON_RESET_EAT_MASK              0x40    /* Set if the Micro Server supports an extended address table */
#define LON_RESET_EAT_SHIFT             6
#define LON_RESET_EAT_FIELD             Flags

#define LON_RESET_IO9_MASK              0x02    /* Indicates the state of the IO9 pin. */
#define LON_RESET_IO9_SHIFT             1
#define LON_RESET_IO9_FIELD             Flags

#define LON_RESET_IO9_VALID_MASK        0x01    /* Indicates whether the state of the IO9 pin is valid or not. */
#define LON_RESET_IO9_VALID_SHIFT       0
#define LON_RESET_IO9_VALID_FIELD       Flags

typedef LON_STRUCT_BEGIN(LonResetNotification)
{
    LonSmipHdr                  Header;             /* message header                                   */

    /*
     *  The following fields were present since Shortstack 2.0
     */
    LonByte                     State;              /* use LON_RESET_STATE_* macros                 */
    LonByte                     Version;            /* link layer protocol version number           */

    /*
     *  The following fields are only present if the link layer protocol version
     *  number (reported via the version field) indicates version 3 or higher
     */
    LonByte                     Flags;
    LonWord                     Key;                /* this Micro Server's key                      */
    LON_ENUM(LonResetCause)     ResetCause;         /* last known cause of Micro Server reset   */
    LON_ENUM(LonSystemError)    ErrorLog;           /* last error from the Micro Server's error log */
    LonUniqueId                 UniqueId;           /*  Micro Server's unique ID (Neuron ID)        */

    LonByte                     MaxAddresses;       /* number of records held in the address table  */
    LonByte                     MaxDomains;         /* number of records held in the domain table   */
    LonByte                     MaxAliases;         /* number of records held in the alias table    */
}
LON_STRUCT_END(LonResetNotification);

/*
 *  Typedef: LonNmNvFetchRequest
 *  Message structure for a NV fetch request.
 *
 *  Previously named NM_NV_fetch_request.
 */
typedef LON_STRUCT_BEGIN(LonNmNvFetchRequest)
{
    LonByte     Index;
    LonWord     EscapeIndex;  /* exists iff index==0xFF    */
}
LON_STRUCT_END(LonNmNvFetchRequest);

/*
 *  Macro: LON_NV_NAME_LEN
 *  The maximum number of bytes in a network variable name, not including the 0
 *  terminator.
 *
 */
#define LON_NV_NAME_LEN 16

/*
 *  Typedef: LonNmInstallRequest
 *  Message structure used with *LonNmInstall* requests.
 *
 *  Each member of this union contains a *Command* field (<LonInstallCommand>)
 *  that specifies the command type.  Even though this structure is defined as
 *  a union, the message size should include only the fields required for the
 *  particular command type.
 */

typedef LON_UNION_BEGIN(LonNmInstallRequest)
{
    LON_STRUCT_NESTED_BEGIN(Wink) {
        LON_ENUM(LonInstallCommand) Command; /* *LonInstallWink* */
    }
    LON_STRUCT_NESTED_END(Wink);

    LON_STRUCT_NESTED_BEGIN(QueryNvInfo) {
        LON_ENUM(LonInstallCommand) Command; /* *LonInstallQueryNvInfo* */
        LON_ENUM(LonNvInfoType)     NvInfoType;  /* Requested network variable information */
        LonWord                     NvIndex; /* Network variable index */

        /* The following parameters are used only if NvInfoType is
         * *LonNvInfoSdText*, and should be omitted when other types of NV
         * information are being queried.
         */
        LON_UNION_NESTED_BEGIN(AdditionalParameters) {
            LON_STRUCT_NESTED_BEGIN(SdText) {
                /* Used when NvInfoType is *LonNvInfoSdText* */
                LonWord Offset;         /* Byte offset from beginning of SD text */
                LonByte Length;         /* Maximum number of SD bytes to return  */
            }
            LON_STRUCT_NESTED_END(SdText);
        }
        LON_UNION_NESTED_END(AdditionalParameters);
    }
    LON_STRUCT_NESTED_END(QueryNvInfo);

    LON_STRUCT_NESTED_BEGIN(QueryNodeInfo) {
        LON_ENUM(LonInstallCommand) Command;      /* *LonInstallQueryNodeInfo*  */
        LON_ENUM(LonNodeInfoType)   NodeInfoType; /* Requested node information */
        LON_UNION_NESTED_BEGIN(AdditionalParameters) {
            LON_STRUCT_NESTED_BEGIN(SdText) {
                /* Used when NodeInfoType is *LonNodeInfoSdText* */
                LonWord Offset;        /* Byte offset from beginning of SD text */
                LonByte Length;        /* Maximum number of SD bytes to return  */
            }
            LON_STRUCT_NESTED_END(SdText);
        }
        LON_UNION_NESTED_END(AdditionalParameters);
    }
    LON_STRUCT_NESTED_END(QueryNodeInfo);

}
LON_UNION_END(LonNmInstallRequest);

/*
 *  Typedef: LonNmInstallResponse
 *  Message structure used with *LonNmInstall* responses.
 *
 */

/*
 * Use the LON_NV_DESC_LENGTH_* macros to access the length field in
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_LENGTH_MASK   0xF8    /* Network variable length */
#define LON_NV_DESC_LENGTH_SHIFT  3
#define LON_NV_DESC_LENGTH_FIELD  LengthAndOrigin

/*
 * Use the LON_NV_DESC_ORIGIN_* macros to access the origin field in
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ORIGIN_MASK   0x07    /* Origin.  Use LonNvOrigin */
#define LON_NV_DESC_ORIGIN_SHIFT  0
#define LON_NV_DESC_ORIGIN_FIELD  LengthAndOrigin

/*
 * Use the LON_NV_DESC_IS_OUTPUT_* macros to access the direction field in
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_IS_OUTPUT_MASK   0x10    /* 1: output, 0: input */
#define LON_NV_DESC_IS_OUTPUT_SHIFT  4
#define LON_NV_DESC_IS_OUTPUT_FIELD  Defaults

/*
 * Use the LON_NV_DESC_DFLT_AUTH_* macros to access the default authentication
 * field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_DFLT_AUTH_MASK   0x08    /* 1: authenticated, 0: unauthenticated */
#define LON_NV_DESC_DFLT_AUTH_SHIFT  3
#define LON_NV_DESC_DFLT_AUTH_FIELD  Defaults

/*
 * Use the LON_NV_DESC_DFLT_PRIORITY_* macros to access the default priority
 * field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_DFLT_PRIORITY_MASK   0x04    /* 1: priority, 0: non-priority */
#define LON_NV_DESC_DFLT_PRIORITY_SHIFT  2
#define LON_NV_DESC_DFLT_PRIORITY_FIELD  Defaults

/*
 * Use the LON_NV_DESC_DFLT_SERVICE_* macros to access the service field in
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_DFLT_SERVICE_MASK   0x03    /* default service type.  Use LonServiceType */
#define LON_NV_DESC_DFLT_SERVICE_SHIFT  0
#define LON_NV_DESC_DFLT_SERVICE_FIELD  Defaults

/*
 * Use the LON_NV_DESC_ATTR_SYNC_* macros to access the nv_sync field in
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_SYNC_MASK   0x40    /* 1: sync NV, 0: non-sync NV */
#define LON_NV_DESC_ATTR_SYNC_SHIFT  6
#define LON_NV_DESC_ATTR_SYNC_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_POLLED_* macros to access the nv_polled field in
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_POLLED_MASK   0x20    /* 1: polled or polling input, 0: not polled */
#define LON_NV_DESC_ATTR_POLLED_SHIFT  5
#define LON_NV_DESC_ATTR_POLLED_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_OFFLINE_* macros to access the nv_offline field in
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_OFFLINE_MASK   0x10    /* 1: take offline prior to updating */
#define LON_NV_DESC_ATTR_OFFLINE_SHIFT  4
#define LON_NV_DESC_ATTR_OFFLINE_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_SRVC_TYPE_CONFIG_* macros to access the
 * nv_service_type_config field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_SRVC_TYPE_CONFIG_MASK   0x08    /* 1: service type is configurable */
#define LON_NV_DESC_ATTR_SRVC_TYPE_CONFIG_SHIFT  3
#define LON_NV_DESC_ATTR_SRVC_TYPE_CONFIG_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_PRIORITY_CONFIG_* macros to access the
 * nv_priority_config field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_PRIORITY_CONFIG_MASK   0x04    /* 1: priority flag is configurable */
#define LON_NV_DESC_ATTR_PRIORITY_CONFIG_SHIFT  2
#define LON_NV_DESC_ATTR_PRIORITY_CONFIG_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_AUTH_CONFIG_* macros to access the nv_auth_config
 * field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_AUTH_CONFIG_MASK   0x02    /* 1: authentication flag is configurable */
#define LON_NV_DESC_ATTR_AUTH_CONFIG_SHIFT  1
#define LON_NV_DESC_ATTR_AUTH_CONFIG_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_ATTR_CONFIG_CLASS_* macros to access the
 * nv_config_class field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_ATTR_CONFIG_CLASS_MASK   0x01    /* 1: a config NV, 0: non-config NV */
#define LON_NV_DESC_ATTR_CONFIG_CLASS_SHIFT  0
#define LON_NV_DESC_ATTR_CONFIG_CLASS_FIELD  BasicAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_MRE_AVAIL_* macros to access the max rate
 * estimate (mre) field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_MRE_AVAIL_MASK   0x80    /* 1: Max rate estimate available using LonInstallQueryNvInfo, LonNvInfoRateEstimate */
#define LON_NV_DESC_EXT_ATTR_MRE_AVAIL_SHIFT  7
#define LON_NV_DESC_EXT_ATTR_MRE_AVAIL_FIELD  ExtendedAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_RE_AVAIL_* macros to access the rate estimate
 * (re) field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_RE_AVAIL_MASK   0x40    /* 1: Average rate estimate available using LonInstallQueryNvInfo, LonNvInfoRateEstimate */
#define LON_NV_DESC_EXT_ATTR_RE_AVAIL_SHIFT  6
#define LON_NV_DESC_EXT_ATTR_RE_AVAIL_FIELD  ExtendedAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_NAME_AVAIL_* macros to access the nv_name
 * field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_NAME_AVAIL_MASK   0x20    /* 1: NV Name is available using LonInstallQueryNvInfo, LonNvInfoName. */
#define LON_NV_DESC_EXT_ATTR_NAME_AVAIL_SHIFT  5
#define LON_NV_DESC_EXT_ATTR_NAME_AVAIL_FIELD  ExtendedAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_SD_AVAIL_* macros to access the sd field in
 * LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_SD_AVAIL_MASK   0x10    /* 1: NV SD text is available using LonInstallQueryNvInfo, LonNvInfoSdText  */
#define LON_NV_DESC_EXT_ATTR_SD_AVAIL_SHIFT  4
#define LON_NV_DESC_EXT_ATTR_SD_AVAIL_FIELD  ExtendedAttributes

/*
 * Use the LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED_* macros to access the
 * name_supplied field in LonNmInstallResponse.NvDescriptor
 */
#define LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED_MASK   0x08    /* 1: Name is supplied in LonNmInstallResponse.NvDescriptor */
#define LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED_SHIFT  3
#define LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED_FIELD  ExtendedAttributes

typedef LON_UNION_BEGIN(LonNmInstallResponse)
{
    /* Response for requested info LonInstallQueryNvInfo, LonNvInfoDescriptor */
    LON_STRUCT_NESTED_BEGIN(NvDescriptor) {
        LonByte LengthAndOrigin;    /* Use LON_NV_DESC_LENGTH_* and LON_NV_DESC_ORIGIN_* macros */
        LonByte Defaults;           /* Use LON_NV_DESC_IS_OUTPUT_* and LON_NV_DESC_DFLT_* macros */
        LonByte BasicAttributes;    /* Use LON_NV_DESC_ATTR_* macros */
        LonByte SnvtIndex;
        LonByte ExtendedAttributes; /* Use LON_NV_DESC_EXT_ATTR_* macros */
        LonWord ArraySize;
        LonWord ArrayElement;
        char    NvName[LON_NV_NAME_LEN]; /* Optional field - Included only if
                                        LON_NV_DESC_EXT_ATTR_NAME_SUPPLIED flag is set. */
    }
    LON_STRUCT_NESTED_END(NvDescriptor);

    /* Response for requested info LonInstallQueryNvInfo, LonNvInfoRateEstimate */
    LON_STRUCT_NESTED_BEGIN(NvRate) {
        LonByte    RateEstimate;       /* Encoded rate estimate. Only valid if 'LON_NV_DESC_EXT_ATTR_RE_AVAIL' is set in NV NvDescriptor */
        LonByte    MaxRateEstimate;    /* Encoded max rate estimate. Only valid if 'LON_NV_DESC_EXT_ATTR_MRE_AVAIL' is set in NV NvDescriptor */
    }
    LON_STRUCT_NESTED_END(NvRate);

    /* Response for requested info LonInstallQueryNvInfo,  LonNvInfoName */
    char    NvName[LON_NV_NAME_LEN];   /* NV name. Only valid if 'nm' set in NV NvDescriptor */

    /* Response for requested info LonInstallQueryNvInfo, LonNvInfoSdText */
    LON_STRUCT_NESTED_BEGIN(NvSd) {
        LonByte    Length;      /* Number of bytes of SD text returned */
        LonByte    Text[1];     /* SD text - actual length is Length above.
                                 * Might not be NULL terminated. */
    }
    LON_STRUCT_NESTED_END(NvSd);

    /* Response for requested info LonInstallQueryNvInfo, LonNvInfoSnvtIndex */
    LonByte    SnvtTypeIndex;

    /* Response for requested info LonInstallQueryNodeInfo, LonNodeInfoSdText */
    LON_STRUCT_NESTED_BEGIN(NodeSd) {
        LonByte    Length;      /* Number of bytes of SD text returned */
        LonByte    Text[1];     /* SD text - actual length is Length above.
                                 * Might not be NULL terminated. */
    }
    LON_STRUCT_NESTED_END(NodeSd);
}
LON_UNION_END(LonNmInstallResponse) ;

/*
 *  Typedef: LonNmSetNodeModeRequest
 *  Message structure for standard network management command *LonNmSetNodeMode*.
 *
 *  Previously named NM_set_node_mode_request.
 */
typedef LON_STRUCT_BEGIN(LonNmSetNodeModeRequest)
{
    LON_ENUM(LonNodeMode)   Mode;
    LON_ENUM(LonNodeState)  State;  /* iff mode == LonChangeState */
}
LON_STRUCT_END(LonNmSetNodeModeRequest);

/*
 *  Enumeration: LonMemoryReadWriteMode
 *  Defines addressing mode for memory read and write request.
 *
 *  Previously named nm_mem_mode.
 */
typedef LON_ENUM_BEGIN(LonMemoryReadWriteMode)
{
    LonAbsoluteMemory           = 0,         /* Address is absolute Neuron memory address */
    LonReadOnlyRelative         = 1,         /* Address is offset into read-only memory structures */
    LonConfigStructRelative     = 2,         /* Address is offset into configuration data structures */
    LonStatisticStructRelative  = 3,         /* Address is offset into statistics data structures */
    LonMemoryModeReserved_A     = 4          /* Reserved for Echelon internal use only */
}
LON_ENUM_END(LonMemoryReadWriteMode);

/*
 *  Enumeration: LonMemoryWriteForm
 *  Defines actions that follow a memory write request.
 *
 *  Previously named nm_mem_form.
 */
typedef LON_ENUM_BEGIN(LonMemoryWriteForm)
{
    LonNoAction                     = 0,
    LonBothCsRecalculation          = 1,
    LonDeltaCsRecalculation         = 3,
    LonConfigCsRecalculation        = 4,
    LonOnlyReset                    = 8,
    LonBothCsRecalculationReset     = 9,
    LonConfigCsRecalculationReset   = 12
}
LON_ENUM_END(LonMemoryWriteForm);

/*
 *  Typedef: LonNmReadMemoryRequest
 *  Message structure used with the *LonNmReadMemory* request.
 *
 *  Previously named NM_read_memory_request.
 */
typedef LON_STRUCT_BEGIN(LonNmReadMemoryRequest)
{
    LON_ENUM(LonMemoryReadWriteMode)    Mode;
    LonWord                             Address;
    LonByte                             Count;
}
LON_STRUCT_END(LonNmReadMemoryRequest);

/*
 *  Typedef: LonNmWriteMemoryRequest
 *  Message structure used with the *LonNmWriteMemory* request.
 *
 *  Note that this structure shows only the message header. The message header
 *  is followed by the data to write, which must be *count* bytes following
 *  the field *Form*.
 *  Previously named NM_write_memory_request.
 */
typedef LON_STRUCT_BEGIN(LonNmWriteMemoryRequest)
{
    LON_ENUM(LonMemoryReadWriteMode)    Mode;
    LonWord                             Address;
    LonByte                             Count;
    LON_ENUM(LonMemoryWriteForm)        Form;
    /* <count> bytes of data following... */
}
LON_STRUCT_END(LonNmWriteMemoryRequest);

/*
 *  Enumeration: LonApplicationMessageCode
 *  Message codes used with application messages.
 *
 *  Application message codes are in the [LonApplicationMsg, LonForeignMsg] range, but
 *  selected values are frequently used and should be avoided: LonApplicationIsi is used
 *  by the interoperable self-installation (ISI) protocol, and LonApplicationFtp is used
 *  for the interoperable file transfer protocol (FTP). When an application is offline and
 *  receives a message in the application code range, it can choose to respond with the
 *  correct response, or to respond with LonApplicationIsOffLine to indicate the application
 *  state and the unavailability of a regular response. Likewise, when the application
 *  receives a meaningful message in the foreign frame code range [LonForeignMsg, LonLastMessageCode],
 *  the application may indicate the unavailability of a meaningful response by sending
 *  a response with the LonForeignIsOffLine code.
 *
 *  Previously named _NA_appl_msg_code.
 */
typedef LON_ENUM_BEGIN(LonApplicationMessageCode)
{
    LonApplicationMsg       = 0x00,
    LonApplicationIsi       = 0x3D,
    LonApplicationFtp       = 0x3E,
    LonApplicationIsOffLine = 0x3F,
    LonForeignMsg           = 0x40,
    LonForeignIsOffLine     = 0x4F,
    LonLastMessageCode      = 0x4F
}
LON_ENUM_END(LonApplicationMessageCode);

/*
 *  Typedef: LonNmQueryDomainRequest
 *  Message structure used with *LonNmQueryDomain*.
 *
 *  Previously named NM_query_domain_request.
 */
typedef LON_STRUCT_BEGIN(LonNmQueryDomainRequest)
{
    LonByte Index;             /* Domain index                 */
}
LON_STRUCT_END(LonNmQueryDomainRequest);

/*
 *  Typedef: LonNmQueryNvAliasRequest
 *  Message structure used with *LonNmQueryNvConfig*.
 *
 *  The Index can either be in the range 0..254 or it can be
 *  255 (escape index). If the latter, the request should also contain
 *  the 16-bit index following this escape index.
 *
 *  This request format is used for targets which do not
 *  support an extended address table (EAT). For those which so, see
 *  the <LonNmQueryNvConfigRequestEat> and <LonNmQueryAliasConfigRequestEat>
 *  definitions.
 */
typedef LON_STRUCT_BEGIN(LonNmQueryNvAliasRequest)
{
    LonByte Index;              /* NV config table index                 */
    LonWord LongIndex;          /* Used only when Index is 255           */
}
LON_STRUCT_END(LonNmQueryNvAliasRequest);

/*
 * Typedef: LonNmQueryNvConfigRequestExp
 * Message structure used with LonNmExpanded, LonExpQueryNvConfig
 *
 * See <LonNmQueryNvAliasRequest> for the classic format.
 * See <LonNmQueryAliasConfigRequestExp> for queries to the alias table.
 */
typedef LON_STRUCT_BEGIN(LonNmQueryNvConfigRequestExp)
{
    LonByte    Subcode;         /* Use LonExpQueryNvConfig */
    LonWord    Index;
}
LON_STRUCT_END(LonNmQueryNvConfigRequestExp);

/*
 * Typedef: LonNmQueryAliasConfigRequestExp
 * Message structure used with LonNmExpanded, LonExpQueryAliasConfig
 *
 * See <LonNmQueryNvAliasRequest> for the classic format.
 * See <LonNmQueryNvConfigRequestExp> for queries to the alias table.
 */
typedef LON_STRUCT_BEGIN(LonNmQueryAliasConfigRequestExp)
{
    LonByte Subcode;            /* Use LonExpQueryAliasConfig */
    LonWord Index;
}
LON_STRUCT_END(LonNmQueryAliasConfigRequestExp);

/*
 *  Typedef: LonNmQueryAddressRequest
 *  Message structure used with *LonNmQueryAddr*.
 */
typedef LON_STRUCT_BEGIN(LonNmQueryAddressRequest)
{
    LonByte Index;             /* address table index                 */
}
LON_STRUCT_END(LonNmQueryAddressRequest);

/*
 *  Typedef: LonNdQueryStatusResponse
 *  Message structure used with responses to *LonNdQueryStatus*.
 *
 *  Previously named ND_query_status_response.
 */
typedef LON_STRUCT_BEGIN(LonNdQueryStatusResponse)
{
    LonStatus   Status;
}
LON_STRUCT_END(LonNdQueryStatusResponse);

/*
 *  Typedef: LonNdQueryXcvrResponse
 *  Message structure used with responses to *LonNdQueryXcvr*.
 *
 *  Previously named ND_query_xcvr_response.
 */
typedef LON_STRUCT_BEGIN(LonNdQueryXcvrResponse)
{
    LonTransceiverParameters    Status;
}
LON_STRUCT_END(LonNdQueryXcvrResponse);

/*
 *  Typedef: LonNmQuerySiDataRequest
 *  Message structure used to receive a request to read the SI/SD data.
 */
typedef LON_STRUCT_BEGIN(LonNmQuerySiDataRequest)
{
    LonWord   Offset;
    LonByte   Count;
}
LON_STRUCT_END(LonNmQuerySiDataRequest);

/*
 *  Typedef: LonNmUpdateAddressRequest
 *  Message structure used with *LonNmUpdateAddr* requests.
 */
typedef LON_STRUCT_BEGIN(LonNmUpdateAddressRequest)
{
    LonByte     Index;
    LonAddress  Address;
}
LON_STRUCT_END(LonNmUpdateAddressRequest);

/*
 *  Typedef: LonNmUpdateNvRequest
 *  Message structure used with *LonNmUpdateNv* request.
 *
 *  This structure is used to update the network variable configuration table
 *  The structure exists in two forms. If the 'shortIndex' field is in the range 0..254,
 *  use the shortForm union member. If the short index equals 255, use the longForm union
 *  member and obtain the true index from the longIndex field.
 *  Note that the data structure shown is an abstraction; the actual message frame used is
 *  the smallest possible.
 *
 *  This message format is used with targets which do not support an extended address
 *  table (EAT). For targets which do support EAT, see <LonNmUpdateNvConfigRequestExp>.
 */
typedef LON_STRUCT_BEGIN(LonNmUpdateNvRequest)
{
    LonByte      ShortIndex;

    LON_UNION_NESTED_BEGIN(Request) {
        LON_STRUCT_NESTED_BEGIN(ShortForm) {
            LonNvConfigNonEat   NvConfig;
        }
        LON_STRUCT_NESTED_END(ShortForm);
        LON_STRUCT_NESTED_BEGIN(LongForm) {
            LonWord         LongIndex;
            LonNvConfigNonEat   NvConfig;
        }
        LON_STRUCT_NESTED_END(LongForm);
    }
    LON_UNION_NESTED_END(Request);
}
LON_STRUCT_END(LonNmUpdateNvRequest);

/*
 * Typedef: LonNmUpdateNvConfigRequestExp
 * Message structure used with LonNmExpanded.LonExpUpdateNvConfig.
 */
typedef LON_STRUCT_BEGIN(LonNmUpdateNvConfigRequestExp)
{
    LonByte Subcode;        /* use LonExpUpdateNvConfig */
    LonWord Index;
    LonNvConfig Config;
}
LON_STRUCT_END(LonNmUpdateNvConfigRequestExp);

/*
 * Typedef: LonNmQueryNvConfigResponseExp
 * Message structure used in response to LonNmExpanded.LonExpQueryNvConfig.
 */
typedef LON_STRUCT_BEGIN(LonNmQueryNvConfigResponseExp)
{
    LonByte Subcode;        /* use LonExpUpdateNvConfig */
    LonNvConfig Config;
}
LON_STRUCT_END(LonNmQueryNvConfigResponseExp);

/*
 *  Typedef: LonNmUpdateAliasRequest
 *  Message structure used with *LonNmUpdateNvConfig* request.
 *
 *  This structure is used to update the alias configuration table.
 *  The structure exists in two forms. If the 'shortIndex' field is in the range 0..254,
 *  use the shortForm union member. If the short index equals 255, use the longForm union
 *  member and obtain the true index from the longIndex field.
 *  The index sent to the Micro Server should be that of the alias plus the network variable count
 *  because the alias table follows the network variable config table and the index continues from that table.
 *  Note that the data structure shown is an abstraction; the actual message frame used is
 *  the smallest possible.
 *
 *  This message format is used with targets which do not support an extended address
 *  table (EAT). For targets which do support EAT, see <LonNmUpdateAliasConfigRequestExp>.
 */

typedef LON_STRUCT_BEGIN(LonNmUpdateAliasRequest)
{
    LonByte      ShortIndex;

    LON_UNION_NESTED_BEGIN(Request) {
        LON_STRUCT_NESTED_BEGIN(ShortForm) {
            LonAliasConfigNonEat  AliasConfig;
        }
        LON_STRUCT_NESTED_END(ShortForm);
        LON_STRUCT_NESTED_BEGIN(LongForm) {
            LonWord         LongIndex;
            LonAliasConfigNonEat  AliasConfig;
        }
        LON_STRUCT_NESTED_END(LongForm);
    }
    LON_UNION_NESTED_END(Request);
}
LON_STRUCT_END(LonNmUpdateAliasRequest);

/*
 * Typedef: LonNmUpdateAliasConfigRequestExp
 * Message structure used with LonNmExpanded.LonExpUpdateAliasConfig.
 */
typedef LON_STRUCT_BEGIN(LonNmUpdateAliasConfigRequestExp)
{
    LonByte    Subcode;     /* use LonExpUpdateAliasConfig */
    LonWord    Index;
    LonNvConfig Alias;
    LonWord    Primary;
}
LON_STRUCT_END(LonNmUpdateAliasConfigRequestExp);

/*
 * Typedef: LonNmQueryAliasConfigResponseExp
 * Message structure used with LonNmExpanded.LonExpQueryAliasConfig.
 */
typedef LON_STRUCT_BEGIN(LonNmQueryAliasConfigResponseExp)
{
    LonByte Subcode;        /* use LonExpQueryAliasConfig */
    LonNvConfig Alias;
    LonWord Primary;
}
LON_STRUCT_END(LonNmQueryAliasConfigResponseExp);

/*
 *  Typedef: LonNmUpdateDomainRequest
 *  Message structure used with the *LonNmUpdateDomain* request.
 */
typedef LON_STRUCT_BEGIN(LonNmUpdateDomainRequest)
{
    LonByte     Index;
    LonDomain   Domain;
}
LON_STRUCT_END(LonNmUpdateDomainRequest);

/*
*  Enumeration: LonServiceType
*  Literals for the service type.
*
*  Previously named ServiceType.
*/
typedef LON_ENUM_BEGIN(LonServiceType)
{
    LonServiceAcknowledged       = 0,    /* ACKD         */
    LonServiceRepeated           = 1,    /* UNACKD_RPT   */
    LonServiceUnacknowledged     = 2,    /* UNACKD       */
    LonServiceRequest            = 3     /* REQUEST      */
}
LON_ENUM_END(LonServiceType);

/*
*  Enumeration: LonMessageType
*  Literals for "msg_type" field
*
*  Previously named MsgType.
*/
typedef LON_ENUM_BEGIN(LonMessageType)
{
    LonMessageExplicit      = 0,    /* TYPE_MSG */
    LonMessageNv            = 1     /* TYPE_NV  */
}
LON_ENUM_END(LonMessageType);

/*
*  Enumeration: LonCompletionCode
*  Literals for 'cmpl_code' fields.
*
*  Previously named ComplType.
*/
typedef LON_ENUM_BEGIN(LonCompletionType)
{
    LonCompletionNotComplete    = 0,             /* MSG_NOT_COMPL, Not a completion event         */
    LonCompletionSuccess        = 1,             /* MSG_SUCCEEDS, Successful completion event    */
    LonCompletionFailure        = 2              /* MSG_FAILS, Failed completion event        */
}
LON_ENUM_END(LonCompletionType);

/*
*  Typedef: LonExplicitMessage
*  Link-layer data structure for explicit (=non-NV) messages
*
*  Previously named ExpMsg.
*/
#define LON_EXPMSG_MSGTYPE_MASK     0x80            /* use LonMessageType */
#define LON_EXPMSG_MSGTYPE_SHIFT    7
#define LON_EXPMSG_MSGTYPE_FIELD    Attributes_1

#define LON_EXPMSG_SERVICE_MASK     0x60            /* use LonServiceType */
#define LON_EXPMSG_SERVICE_SHIFT    5
#define LON_EXPMSG_SERVICE_FIELD    Attributes_1

#define LON_EXPMSG_AUTHENTICATED_MASK   0x10        /* use LonBool   */
#define LON_EXPMSG_AUTHENTICATED_SHIFT  4
#define LON_EXPMSG_AUTHENTICATED_FIELD  Attributes_1

#define LON_EXPMSG_TAG_MASK         0x0F
#define LON_EXPMSG_TAG_SHIFT        0
#define LON_EXPMSG_TAG_FIELD        Attributes_1

#define LON_EXPMSG_PRIORITY_MASK    0x80           /* use LonBool */
#define LON_EXPMSG_PRIORITY_SHIFT   7
#define LON_EXPMSG_PRIORITY_FIELD   Attributes_2

#define LON_EXPMSG_PATH_MASK        0x40            /* use LonBool. True -> use alternate path */
#define LON_EXPMSG_PATH_SHIFT       6
#define LON_EXPMSG_PATH_FIELD       Attributes_2

#define LON_EXPMSG_COMPLETIONCODE_MASK  0x30            /* use LonCompletionType */
#define LON_EXPMSG_COMPLETIONCODE_SHIFT 4
#define LON_EXPMSG_COMPLETIONCODE_FIELD Attributes_2

#define LON_EXPMSG_EXPLICITADDR_MASK    0x08            /* use LonBool. True -> use explicit address (implicit via address table otherwise) */
#define LON_EXPMSG_EXPLICITADDR_SHIFT   3
#define LON_EXPMSG_EXPLICITADDR_FIELD   Attributes_2

#define LON_EXPMSG_ALTPATH_MASK     0x04            /* use LonBool. True -> use path specified in 'path'. Use default otherwise */
#define LON_EXPMSG_ALTPATH_SHIFT    2
#define LON_EXPMSG_ALTPATH_FIELD    Attributes_2

#define LON_EXPMSG_POOL_MASK        0x02            /* use LonBool. True -> incoming */
#define LON_EXPMSG_POOL_SHIFT       1
#define LON_EXPMSG_POOL_FIELD       Attributes_2

#define LON_EXPMSG_RESPONSE_MASK    0x01            /* use LonBool. Set to True for responses only */
#define LON_EXPMSG_RESPONSE_SHIFT   0
#define LON_EXPMSG_RESPONSE_FIELD   Attributes_2

typedef LON_STRUCT_BEGIN(LonExplicitMessage)
{
    LonByte      Attributes_1;   /* contains msgType, serviceType, authenticated, tag. Use LON_EXPMSG_* macros */
    LonByte      Attributes_2;   /* contains priority, path, completionCode, explicitAddressing, altPath, pool, response. Use LON_EXPMSG_* macros */
    LonByte      Length;         /* Length of message code and data to follow    */
    /* not including any explicit address field.    */
#if LON_EXPLICIT_ADDRESSING
    LonExplicitAddress  Address; /* Optional explicit addressing information   */
#endif  /* LON_EXPLICIT_ADDRESSING */
    LonByte      Code;           /* Message code                                 */
    LON_UNION_BEGIN(Data) {      /* Message data                                 */
        LonByte                     Data[1];
        LonNmNvFetchRequest         NvFetch;
        LonNmInstallRequest         Install;
        LonNmSetNodeModeRequest     NodeMode;
        LonNmReadMemoryRequest      ReadMemory;
        LonNmWriteMemoryRequest     WriteMemory;
        LonNmQuerySiDataRequest     QuerySiDataRequest;
#if LON_NM_QUERY_FUNCTIONS
        LonNmQueryDomainRequest     QueryDomainRequest;
        LonNmQueryNvAliasRequest    QueryNvAliasRequest;
        LonNmQueryNvConfigRequestExp QueryNvConfigRequestExp;
        LonNmQueryAliasConfigRequestExp QueryAliasConfigRequestExp;
        LonNmQueryAddressRequest    QueryAddressRequest;
        LonNdQueryStatusResponse    QueryStatusResponse;
        LonNdQueryXcvrResponse      QueryXcvrStatusResponse;
#endif  /* LON_NM_QUERY_FUNCTIONS */
#if LON_NM_UPDATE_FUNCTIONS
        LonNmUpdateAddressRequest   UpdateAddressRequest;
        LonNmUpdateDomainRequest    UpdateDomainRequest;
        LonNmUpdateNvRequest        UpdateNvRequest;
        LonNmUpdateNvConfigRequestExp       UpdateNvConfigRequestExp;
        LonNmUpdateAliasConfigRequestExp    UpdateAliasConfigRequestExp;
        LonNmUpdateAliasRequest     UpdateAliasRequest;
#endif  /* LON_NM_UPDATE_FUNCTIONS */
    }
    LON_UNION_END(Data);
}
LON_STRUCT_END(LonExplicitMessage);

#define LON_SICB_MIN_OVERHEAD ( sizeof(LonExplicitMessage) - sizeof(((LonExplicitMessage*)0x0)->Data) )

/* Literal defines the maximum explicit message data size */
#define LON_MAX_MSG_DATA (LON_SMIP_MAX_DATA - LON_SICB_MIN_OVERHEAD)

/*
*  Typedef: LonNvMessage
*  Link-layer data structure for network variable messages
*
*  Previously named NvMsg.
*/
#define LON_NVMSG_MSGTYPE_MASK      0x80        /* use LonMessageType */
#define LON_NVMSG_MSGTYPE_SHIFT     7
#define LON_NVMSG_MSGTYPE_FIELD     Attributes_1

#define LON_NVMSG_NVPOLL_MASK       0x40        /* use LonBool   */
#define LON_NVMSG_NVPOLL_SHIFT      6
#define LON_NVMSG_NVPOLL_FIELD      Attributes_1

#define LON_NVMSG_TAG_MASK          0x0F        /* tag, correlates responses and completion events */
#define LON_NVMSG_TAG_SHIFT         0
#define LON_NVMSG_TAG_FIELD         Attributes_1

#define LON_NVMSG_PRIORITY_MASK     0x80        /* use LonBool */
#define LON_NVMSG_PRIORITY_SHIFT    7
#define LON_NVMSG_PRIORITY_FIELD    Attributes_2

#define LON_NVMSG_PATH_MASK         0x40         /* Use LonBool. False: use primary path (incoming only) */
#define LON_NVMSG_PATH_SHIFT        6
#define LON_NVMSG_PATH_FIELD        Attributes_2

#define LON_NVMSG_COMPLETIONCODE_MASK    0x30        /* Use LonCompletionCode */
#define LON_NVMSG_COMPLETIONCODE_SHIFT   4
#define LON_NVMSG_COMPLETIONCODE_FIELD   Attributes_2

#define LON_NVMSG_EXPLADDR_MASK     0x08            /* use LonBool. True -> use explicit address (implicit via address table otherwise) */
#define LON_NVMSG_EXPLADDR_SHIFT    3
#define LON_NVMSG_EXPLADDR_FIELD    Attributes_2

#define LON_NVMSG_TURNAROUND_MASK   0x04            /* use LonBool. True -> turnaround poll, False -> other */
#define LON_NVMSG_TURNAROUND_SHIFT  2
#define LON_NVMSG_TURNAROUND_FIELD  Attributes_2

#define LON_NVMSG_POOL_MASK         0x02            /* use LonBool. True -> incoming */
#define LON_NVMSG_POOL_SHIFT        1
#define LON_NVMSG_POOL_FIELD        Attributes_2

#define LON_NVMSG_RESPONSE_MASK     0x01            /* use LonBool. Set to True for responses only */
#define LON_NVMSG_RESPONSE_SHIFT    0
#define LON_NVMSG_RESPONSE_FIELD    Attributes_2

typedef LON_STRUCT_BEGIN(LonNvMessage)
{
    LonByte             Attributes_1;       /* contains msgType, nvPoll, and tag (4th and 5th bits are unused). Use LON_NVMSG_* macros */
    LonByte             Attributes_2;       /* contains priority, path, completionCode, addressingMode, turnaround, pool, and response. Use LON_NVMSG_* macros. */

    LonByte             Length;             /* Length of network variable data to follow    */
    /* not including any explicit address field.    */
#if LON_EXPLICIT_ADDRESSING
    LonExplicitAddress  Address;   /* Optional explicit addressing information   */
#endif
    LonByte             Index;              /* NV index                                     */
    LonByte             AliasIndex;         /* Alias index.                                 */
    LonByte             NvData[1];          /* "length" bytes of NV data                    */
}
LON_STRUCT_END(LonNvMessage);

/* Literal defines the maximum NV size    */
#define LON_MAX_MSG_NV_DATA (LON_SMIP_MAX_DATA - sizeof(LonNvMessage) + 1)

/*
*  Typedef: LonSicb
*  Serial interface control block
*
*  Message payload structure with niCOMM/niNETMGMT messages.
*  It's a union of LonExplicitMessage and LonNvMessage.
****************************************************************************
*/

typedef LON_UNION_BEGIN(LonSicb)
{
    LonExplicitMessage  ExplicitMessage;
    LonNvMessage        NvMessage;
}
LON_UNION_END(LonSicb);

/*
 * Turn off platform specific pragmas, definitions, and so on.
 * For example, restore packing directives.
 */
#ifdef  INCLUDE_LON_BEGIN_END
#   include "LonEnd.h"
#endif  /* INCLUDE_LON_BEGIN_END */

#endif /* _SHORTSTACK_TYPES_H */
